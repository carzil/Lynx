Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    GENERATOR
    DEFAULT
    BNOT
    DOT
    CASE
    PRIVATE
    COLON
    NAMESPACE
    CIRCUMFLEXUS
    AMPER
    IMPORT
    STRUCT
    AS
    CLASS
    SWITCH
    PUBLIC

Grammar

Rule 0     S' -> program
Rule 1     program -> input
Rule 2     input -> op
Rule 3     input -> input op
Rule 4     input -> <empty>
Rule 5     op -> expr SEMICOLON
Rule 6     op -> stmt SEMICOLON
Rule 7     stmt -> def_stmt
Rule 8     stmt -> if_stmt
Rule 9     stmt -> call_stmt
Rule 10    stmt -> while_stmt
Rule 11    stmt -> for_stmt
Rule 12    stmt -> assign
Rule 13    if_stmt -> IF expr THEN code_block elseifs_stmts else_stmt
Rule 14    if_stmt -> IF LPAR expr RPAR code_block elseifs_stmts else_stmt
Rule 15    elseifs_stmts -> elseifs_stmts elseif_stmt
Rule 16    elseifs_stmts -> elseif_stmt
Rule 17    elseifs_stmts -> <empty>
Rule 18    elseif_stmt -> ELSEIF expr THEN code_block
Rule 19    elseif_stmt -> ELSEIF LPAR expr RPAR code_block
Rule 20    else_stmt -> ELSE THEN code_block
Rule 21    else_stmt -> ELSE code_block
Rule 22    while_stmt -> WHILE LPAR expr RPAR code_block
Rule 23    while_stmt -> WHILE LPAR expr RPAR THEN code_block
Rule 24    for_stmt -> FOR LPAR assign SEMICOLON expr SEMICOLON expr RPAR code_block
Rule 25    for_stmt -> FOR LPAR expr SEMICOLON expr SEMICOLON expr RPAR THEN code_block
Rule 26    def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS type THEN code_block
Rule 27    def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS type code_block
Rule 28    var_prototypes_list -> var_prototypes_list COMMA var_prototype
Rule 29    var_prototypes_list -> var_prototype
Rule 30    var_prototype -> ID TYPEIS type
Rule 31    call_stmt -> ID LPAR RPAR
Rule 32    call_stmt -> ID LPAR args_list RPAR
Rule 33    assign -> ID TYPEIS type EQUAL expr
Rule 34    assign -> assign_left EQUAL expr
Rule 35    assign -> assign_left PE expr
Rule 36    assign -> assign_left ME expr
Rule 37    assign -> assign_left SE expr
Rule 38    assign -> assign_left DSE expr
Rule 39    assign -> assign_left AE expr
Rule 40    assign -> assign_left DAE expr
Rule 41    assign_left -> ID
Rule 42    assign_left -> index_expr
Rule 43    args_list -> expr
Rule 44    args_list -> args_list COMMA expr
Rule 45    expr -> par_expr
Rule 46    expr -> test
Rule 47    expr -> return_expr
Rule 48    expr -> index_expr
Rule 49    index_expr -> ID LSQB expr RSQB
Rule 50    test -> test AND cmp
Rule 51    test -> test OR cmp
Rule 52    test -> cmp
Rule 53    cmp -> cmp LT cmp_expr
Rule 54    cmp -> cmp GT cmp_expr
Rule 55    cmp -> cmp LE cmp_expr
Rule 56    cmp -> cmp GE cmp_expr
Rule 57    cmp -> cmp NE cmp_expr
Rule 58    cmp -> cmp DEQUAL cmp_expr
Rule 59    cmp -> cmp_expr
Rule 60    cmp_expr -> or
Rule 61    or -> or BOR xor
Rule 62    or -> xor
Rule 63    xor -> xor BXOR and
Rule 64    xor -> and
Rule 65    and -> and BAND shift
Rule 66    and -> shift
Rule 67    shift -> and SHIFTLEFT shift
Rule 68    shift -> and SHIFTRIGTH shift
Rule 69    shift -> arith
Rule 70    par_expr -> LPAR arith RPAR
Rule 71    arith -> arith PLUS term
Rule 72    arith -> arith MINUS term
Rule 73    arith -> term
Rule 74    term -> term MUL factor
Rule 75    term -> term DIV factor
Rule 76    term -> term MOD factor
Rule 77    term -> term POW factor
Rule 78    term -> term DIV2 factor
Rule 79    term -> factor
Rule 80    factor -> atom
Rule 81    factor -> EMARK atom
Rule 82    factor -> MINUS atom
Rule 83    factor -> PLUS atom
Rule 84    factor -> NOT atom
Rule 85    atom -> primary
Rule 86    atom -> call_stmt
Rule 87    primary -> ID
Rule 88    primary -> NUMBER
Rule 89    primary -> FLOAT
Rule 90    primary -> STRING
Rule 91    primary -> list_def
Rule 92    list_def -> LSQB RSQB
Rule 93    list_def -> LSQB primary_list RSQB
Rule 94    primary_list -> primary
Rule 95    primary_list -> primary_list COMMA primary
Rule 96    type -> TINT
Rule 97    type -> TLONG
Rule 98    type -> TFLOAT
Rule 99    type -> ARRAY
Rule 100   type -> TUPLE
Rule 101   type -> CINT
Rule 102   type -> CLONG
Rule 103   type -> CFLOAT
Rule 104   code_block -> LBRACE input RBRACE
Rule 105   return_expr -> RETURN test

Terminals, with rules where they appear

AE                   : 39
AMPER                : 
AND                  : 50
ARRAY                : 99
AS                   : 
BAND                 : 65
BNOT                 : 
BOR                  : 61
BXOR                 : 63
CASE                 : 
CFLOAT               : 103
CINT                 : 101
CIRCUMFLEXUS         : 
CLASS                : 
CLONG                : 102
COLON                : 
COMMA                : 28 44 95
DAE                  : 40
DEF                  : 26 27
DEFAULT              : 
DEQUAL               : 58
DIV                  : 75
DIV2                 : 78
DOT                  : 
DSE                  : 38
ELSE                 : 20 21
ELSEIF               : 18 19
EMARK                : 81
EQUAL                : 33 34
FLOAT                : 89
FOR                  : 24 25
GE                   : 56
GENERATOR            : 
GT                   : 54
ID                   : 26 27 30 31 32 33 41 49 87
IF                   : 13 14
IMPORT               : 
LBRACE               : 104
LE                   : 55
LPAR                 : 14 19 22 23 24 25 26 27 31 32 70
LSQB                 : 49 92 93
LT                   : 53
ME                   : 36
MINUS                : 72 82
MOD                  : 76
MUL                  : 74
NAMESPACE            : 
NE                   : 57
NOT                  : 84
NUMBER               : 88
OR                   : 51
PE                   : 35
PLUS                 : 71 83
POW                  : 77
PRIVATE              : 
PUBLIC               : 
RBRACE               : 104
RETURN               : 105
RPAR                 : 14 19 22 23 24 25 26 27 31 32 70
RSQB                 : 49 92 93
SE                   : 37
SEMICOLON            : 5 6 24 24 25 25
SHIFTLEFT            : 67
SHIFTRIGTH           : 68
STRING               : 90
STRUCT               : 
SWITCH               : 
TFLOAT               : 98
THEN                 : 13 18 20 23 25 26
TINT                 : 96
TLONG                : 97
TUPLE                : 100
TYPEIS               : 26 27 30 33
WHILE                : 22 23
error                : 

Nonterminals, with rules where they appear

and                  : 63 64 65 67 68
args_list            : 32 44
arith                : 69 70 71 72
assign               : 12 24
assign_left          : 34 35 36 37 38 39 40
atom                 : 80 81 82 83 84
call_stmt            : 9 86
cmp                  : 50 51 52 53 54 55 56 57 58
cmp_expr             : 53 54 55 56 57 58 59
code_block           : 13 14 18 19 20 21 22 23 24 25 26 27
def_stmt             : 7
else_stmt            : 13 14
elseif_stmt          : 15 16
elseifs_stmts        : 13 14 15
expr                 : 5 13 14 18 19 22 23 24 24 25 25 25 33 34 35 36 37 38 39 40 43 44 49
factor               : 74 75 76 77 78 79
for_stmt             : 11
if_stmt              : 8
index_expr           : 42 48
input                : 1 3 104
list_def             : 91
op                   : 2 3
or                   : 60 61
par_expr             : 45
primary              : 85 94 95
primary_list         : 93 95
program              : 0
return_expr          : 47
shift                : 65 66 67 68
stmt                 : 6
term                 : 71 72 73 74 75 76 77 78
test                 : 46 50 51 105
type                 : 26 27 30 33
var_prototype        : 28 29
var_prototypes_list  : 26 27 28
while_stmt           : 10
xor                  : 61 62 63

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . input
    (2) input -> . op
    (3) input -> . input op
    (4) input -> .
    (5) op -> . expr SEMICOLON
    (6) op -> . stmt SEMICOLON
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (7) stmt -> . def_stmt
    (8) stmt -> . if_stmt
    (9) stmt -> . call_stmt
    (10) stmt -> . while_stmt
    (11) stmt -> . for_stmt
    (12) stmt -> . assign
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (26) def_stmt -> . DEF ID LPAR var_prototypes_list RPAR TYPEIS type THEN code_block
    (27) def_stmt -> . DEF ID LPAR var_prototypes_list RPAR TYPEIS type code_block
    (13) if_stmt -> . IF expr THEN code_block elseifs_stmts else_stmt
    (14) if_stmt -> . IF LPAR expr RPAR code_block elseifs_stmts else_stmt
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (22) while_stmt -> . WHILE LPAR expr RPAR code_block
    (23) while_stmt -> . WHILE LPAR expr RPAR THEN code_block
    (24) for_stmt -> . FOR LPAR assign SEMICOLON expr SEMICOLON expr RPAR code_block
    (25) for_stmt -> . FOR LPAR expr SEMICOLON expr SEMICOLON expr RPAR THEN code_block
    (33) assign -> . ID TYPEIS type EQUAL expr
    (34) assign -> . assign_left EQUAL expr
    (35) assign -> . assign_left PE expr
    (36) assign -> . assign_left ME expr
    (37) assign -> . assign_left SE expr
    (38) assign -> . assign_left DSE expr
    (39) assign -> . assign_left AE expr
    (40) assign -> . assign_left DAE expr
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (41) assign_left -> . ID
    (42) assign_left -> . index_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

  ! shift/reduce conflict for LPAR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for EMARK resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LSQB resolved as shift
    $end            reduce using rule 4 (input -> .)
    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 31
    DEF             shift and go to state 11
    IF              shift and go to state 33
    WHILE           shift and go to state 8
    FOR             shift and go to state 23
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

  ! LPAR            [ reduce using rule 4 (input -> .) ]
  ! RETURN          [ reduce using rule 4 (input -> .) ]
  ! ID              [ reduce using rule 4 (input -> .) ]
  ! DEF             [ reduce using rule 4 (input -> .) ]
  ! IF              [ reduce using rule 4 (input -> .) ]
  ! WHILE           [ reduce using rule 4 (input -> .) ]
  ! FOR             [ reduce using rule 4 (input -> .) ]
  ! EMARK           [ reduce using rule 4 (input -> .) ]
  ! MINUS           [ reduce using rule 4 (input -> .) ]
  ! PLUS            [ reduce using rule 4 (input -> .) ]
  ! NOT             [ reduce using rule 4 (input -> .) ]
  ! NUMBER          [ reduce using rule 4 (input -> .) ]
  ! FLOAT           [ reduce using rule 4 (input -> .) ]
  ! STRING          [ reduce using rule 4 (input -> .) ]
  ! LSQB            [ reduce using rule 4 (input -> .) ]

    and                            shift and go to state 1
    par_expr                       shift and go to state 6
    def_stmt                       shift and go to state 7
    primary                        shift and go to state 26
    assign_left                    shift and go to state 9
    cmp_expr                       shift and go to state 17
    xor                            shift and go to state 12
    list_def                       shift and go to state 13
    program                        shift and go to state 15
    factor                         shift and go to state 5
    test                           shift and go to state 18
    input                          shift and go to state 19
    arith                          shift and go to state 20
    index_expr                     shift and go to state 21
    call_stmt                      shift and go to state 24
    return_expr                    shift and go to state 25
    stmt                           shift and go to state 27
    for_stmt                       shift and go to state 28
    atom                           shift and go to state 29
    term                           shift and go to state 34
    if_stmt                        shift and go to state 35
    expr                           shift and go to state 36
    or                             shift and go to state 37
    while_stmt                     shift and go to state 39
    shift                          shift and go to state 40
    op                             shift and go to state 42
    assign                         shift and go to state 38
    cmp                            shift and go to state 43

state 1

    (64) xor -> and .
    (65) and -> and . BAND shift
    (67) shift -> and . SHIFTLEFT shift
    (68) shift -> and . SHIFTRIGTH shift

    BXOR            reduce using rule 64 (xor -> and .)
    BOR             reduce using rule 64 (xor -> and .)
    LT              reduce using rule 64 (xor -> and .)
    GT              reduce using rule 64 (xor -> and .)
    LE              reduce using rule 64 (xor -> and .)
    GE              reduce using rule 64 (xor -> and .)
    NE              reduce using rule 64 (xor -> and .)
    DEQUAL          reduce using rule 64 (xor -> and .)
    AND             reduce using rule 64 (xor -> and .)
    OR              reduce using rule 64 (xor -> and .)
    SEMICOLON       reduce using rule 64 (xor -> and .)
    THEN            reduce using rule 64 (xor -> and .)
    RPAR            reduce using rule 64 (xor -> and .)
    COMMA           reduce using rule 64 (xor -> and .)
    RSQB            reduce using rule 64 (xor -> and .)
    BAND            shift and go to state 44
    SHIFTLEFT       shift and go to state 46
    SHIFTRIGTH      shift and go to state 45


state 2

    (70) par_expr -> LPAR . arith RPAR
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    term                           shift and go to state 34
    arith                          shift and go to state 47
    call_stmt                      shift and go to state 48
    factor                         shift and go to state 5
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 3

    (89) primary -> FLOAT .

    MUL             reduce using rule 89 (primary -> FLOAT .)
    DIV             reduce using rule 89 (primary -> FLOAT .)
    MOD             reduce using rule 89 (primary -> FLOAT .)
    POW             reduce using rule 89 (primary -> FLOAT .)
    DIV2            reduce using rule 89 (primary -> FLOAT .)
    PLUS            reduce using rule 89 (primary -> FLOAT .)
    MINUS           reduce using rule 89 (primary -> FLOAT .)
    BAND            reduce using rule 89 (primary -> FLOAT .)
    SHIFTLEFT       reduce using rule 89 (primary -> FLOAT .)
    SHIFTRIGTH      reduce using rule 89 (primary -> FLOAT .)
    BXOR            reduce using rule 89 (primary -> FLOAT .)
    BOR             reduce using rule 89 (primary -> FLOAT .)
    LT              reduce using rule 89 (primary -> FLOAT .)
    GT              reduce using rule 89 (primary -> FLOAT .)
    LE              reduce using rule 89 (primary -> FLOAT .)
    GE              reduce using rule 89 (primary -> FLOAT .)
    NE              reduce using rule 89 (primary -> FLOAT .)
    DEQUAL          reduce using rule 89 (primary -> FLOAT .)
    AND             reduce using rule 89 (primary -> FLOAT .)
    OR              reduce using rule 89 (primary -> FLOAT .)
    SEMICOLON       reduce using rule 89 (primary -> FLOAT .)
    THEN            reduce using rule 89 (primary -> FLOAT .)
    RPAR            reduce using rule 89 (primary -> FLOAT .)
    COMMA           reduce using rule 89 (primary -> FLOAT .)
    RSQB            reduce using rule 89 (primary -> FLOAT .)


state 4

    (105) return_expr -> RETURN . test
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    xor                            shift and go to state 12
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5
    test                           shift and go to state 50
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 5

    (79) term -> factor .

    MUL             reduce using rule 79 (term -> factor .)
    DIV             reduce using rule 79 (term -> factor .)
    MOD             reduce using rule 79 (term -> factor .)
    POW             reduce using rule 79 (term -> factor .)
    DIV2            reduce using rule 79 (term -> factor .)
    PLUS            reduce using rule 79 (term -> factor .)
    MINUS           reduce using rule 79 (term -> factor .)
    BAND            reduce using rule 79 (term -> factor .)
    SHIFTLEFT       reduce using rule 79 (term -> factor .)
    SHIFTRIGTH      reduce using rule 79 (term -> factor .)
    BXOR            reduce using rule 79 (term -> factor .)
    BOR             reduce using rule 79 (term -> factor .)
    LT              reduce using rule 79 (term -> factor .)
    GT              reduce using rule 79 (term -> factor .)
    LE              reduce using rule 79 (term -> factor .)
    GE              reduce using rule 79 (term -> factor .)
    NE              reduce using rule 79 (term -> factor .)
    DEQUAL          reduce using rule 79 (term -> factor .)
    AND             reduce using rule 79 (term -> factor .)
    OR              reduce using rule 79 (term -> factor .)
    RPAR            reduce using rule 79 (term -> factor .)
    COMMA           reduce using rule 79 (term -> factor .)
    SEMICOLON       reduce using rule 79 (term -> factor .)
    THEN            reduce using rule 79 (term -> factor .)
    RSQB            reduce using rule 79 (term -> factor .)


state 6

    (45) expr -> par_expr .

    SEMICOLON       reduce using rule 45 (expr -> par_expr .)
    RPAR            reduce using rule 45 (expr -> par_expr .)
    COMMA           reduce using rule 45 (expr -> par_expr .)
    THEN            reduce using rule 45 (expr -> par_expr .)
    RSQB            reduce using rule 45 (expr -> par_expr .)


state 7

    (7) stmt -> def_stmt .

    SEMICOLON       reduce using rule 7 (stmt -> def_stmt .)


state 8

    (22) while_stmt -> WHILE . LPAR expr RPAR code_block
    (23) while_stmt -> WHILE . LPAR expr RPAR THEN code_block

    LPAR            shift and go to state 51


state 9

    (34) assign -> assign_left . EQUAL expr
    (35) assign -> assign_left . PE expr
    (36) assign -> assign_left . ME expr
    (37) assign -> assign_left . SE expr
    (38) assign -> assign_left . DSE expr
    (39) assign -> assign_left . AE expr
    (40) assign -> assign_left . DAE expr

    EQUAL           shift and go to state 55
    PE              shift and go to state 56
    ME              shift and go to state 52
    SE              shift and go to state 58
    DSE             shift and go to state 57
    AE              shift and go to state 54
    DAE             shift and go to state 53


state 10

    (81) factor -> EMARK . atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    call_stmt                      shift and go to state 48
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 59

state 11

    (26) def_stmt -> DEF . ID LPAR var_prototypes_list RPAR TYPEIS type THEN code_block
    (27) def_stmt -> DEF . ID LPAR var_prototypes_list RPAR TYPEIS type code_block

    ID              shift and go to state 60


state 12

    (62) or -> xor .
    (63) xor -> xor . BXOR and

    BOR             reduce using rule 62 (or -> xor .)
    LT              reduce using rule 62 (or -> xor .)
    GT              reduce using rule 62 (or -> xor .)
    LE              reduce using rule 62 (or -> xor .)
    GE              reduce using rule 62 (or -> xor .)
    NE              reduce using rule 62 (or -> xor .)
    DEQUAL          reduce using rule 62 (or -> xor .)
    AND             reduce using rule 62 (or -> xor .)
    OR              reduce using rule 62 (or -> xor .)
    SEMICOLON       reduce using rule 62 (or -> xor .)
    RPAR            reduce using rule 62 (or -> xor .)
    COMMA           reduce using rule 62 (or -> xor .)
    THEN            reduce using rule 62 (or -> xor .)
    RSQB            reduce using rule 62 (or -> xor .)
    BXOR            shift and go to state 61


state 13

    (91) primary -> list_def .

    MUL             reduce using rule 91 (primary -> list_def .)
    DIV             reduce using rule 91 (primary -> list_def .)
    MOD             reduce using rule 91 (primary -> list_def .)
    POW             reduce using rule 91 (primary -> list_def .)
    DIV2            reduce using rule 91 (primary -> list_def .)
    PLUS            reduce using rule 91 (primary -> list_def .)
    MINUS           reduce using rule 91 (primary -> list_def .)
    BAND            reduce using rule 91 (primary -> list_def .)
    SHIFTLEFT       reduce using rule 91 (primary -> list_def .)
    SHIFTRIGTH      reduce using rule 91 (primary -> list_def .)
    BXOR            reduce using rule 91 (primary -> list_def .)
    BOR             reduce using rule 91 (primary -> list_def .)
    LT              reduce using rule 91 (primary -> list_def .)
    GT              reduce using rule 91 (primary -> list_def .)
    LE              reduce using rule 91 (primary -> list_def .)
    GE              reduce using rule 91 (primary -> list_def .)
    NE              reduce using rule 91 (primary -> list_def .)
    DEQUAL          reduce using rule 91 (primary -> list_def .)
    AND             reduce using rule 91 (primary -> list_def .)
    OR              reduce using rule 91 (primary -> list_def .)
    SEMICOLON       reduce using rule 91 (primary -> list_def .)
    THEN            reduce using rule 91 (primary -> list_def .)
    RPAR            reduce using rule 91 (primary -> list_def .)
    COMMA           reduce using rule 91 (primary -> list_def .)
    RSQB            reduce using rule 91 (primary -> list_def .)


state 14

    (82) factor -> MINUS . atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    call_stmt                      shift and go to state 48
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 62

state 15

    (0) S' -> program .



state 16

    (83) factor -> PLUS . atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    call_stmt                      shift and go to state 48
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 63

state 17

    (59) cmp -> cmp_expr .

    LT              reduce using rule 59 (cmp -> cmp_expr .)
    GT              reduce using rule 59 (cmp -> cmp_expr .)
    LE              reduce using rule 59 (cmp -> cmp_expr .)
    GE              reduce using rule 59 (cmp -> cmp_expr .)
    NE              reduce using rule 59 (cmp -> cmp_expr .)
    DEQUAL          reduce using rule 59 (cmp -> cmp_expr .)
    AND             reduce using rule 59 (cmp -> cmp_expr .)
    OR              reduce using rule 59 (cmp -> cmp_expr .)
    SEMICOLON       reduce using rule 59 (cmp -> cmp_expr .)
    RPAR            reduce using rule 59 (cmp -> cmp_expr .)
    THEN            reduce using rule 59 (cmp -> cmp_expr .)
    COMMA           reduce using rule 59 (cmp -> cmp_expr .)
    RSQB            reduce using rule 59 (cmp -> cmp_expr .)


state 18

    (46) expr -> test .
    (50) test -> test . AND cmp
    (51) test -> test . OR cmp

    SEMICOLON       reduce using rule 46 (expr -> test .)
    RPAR            reduce using rule 46 (expr -> test .)
    COMMA           reduce using rule 46 (expr -> test .)
    THEN            reduce using rule 46 (expr -> test .)
    RSQB            reduce using rule 46 (expr -> test .)
    AND             shift and go to state 64
    OR              shift and go to state 65


state 19

    (1) program -> input .
    (3) input -> input . op
    (5) op -> . expr SEMICOLON
    (6) op -> . stmt SEMICOLON
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (7) stmt -> . def_stmt
    (8) stmt -> . if_stmt
    (9) stmt -> . call_stmt
    (10) stmt -> . while_stmt
    (11) stmt -> . for_stmt
    (12) stmt -> . assign
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (26) def_stmt -> . DEF ID LPAR var_prototypes_list RPAR TYPEIS type THEN code_block
    (27) def_stmt -> . DEF ID LPAR var_prototypes_list RPAR TYPEIS type code_block
    (13) if_stmt -> . IF expr THEN code_block elseifs_stmts else_stmt
    (14) if_stmt -> . IF LPAR expr RPAR code_block elseifs_stmts else_stmt
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (22) while_stmt -> . WHILE LPAR expr RPAR code_block
    (23) while_stmt -> . WHILE LPAR expr RPAR THEN code_block
    (24) for_stmt -> . FOR LPAR assign SEMICOLON expr SEMICOLON expr RPAR code_block
    (25) for_stmt -> . FOR LPAR expr SEMICOLON expr SEMICOLON expr RPAR THEN code_block
    (33) assign -> . ID TYPEIS type EQUAL expr
    (34) assign -> . assign_left EQUAL expr
    (35) assign -> . assign_left PE expr
    (36) assign -> . assign_left ME expr
    (37) assign -> . assign_left SE expr
    (38) assign -> . assign_left DSE expr
    (39) assign -> . assign_left AE expr
    (40) assign -> . assign_left DAE expr
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (41) assign_left -> . ID
    (42) assign_left -> . index_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    $end            reduce using rule 1 (program -> input .)
    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 31
    DEF             shift and go to state 11
    IF              shift and go to state 33
    WHILE           shift and go to state 8
    FOR             shift and go to state 23
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    par_expr                       shift and go to state 6
    def_stmt                       shift and go to state 7
    primary                        shift and go to state 26
    assign_left                    shift and go to state 9
    cmp_expr                       shift and go to state 17
    xor                            shift and go to state 12
    list_def                       shift and go to state 13
    factor                         shift and go to state 5
    test                           shift and go to state 18
    arith                          shift and go to state 20
    index_expr                     shift and go to state 21
    call_stmt                      shift and go to state 24
    return_expr                    shift and go to state 25
    stmt                           shift and go to state 27
    for_stmt                       shift and go to state 28
    atom                           shift and go to state 29
    term                           shift and go to state 34
    if_stmt                        shift and go to state 35
    expr                           shift and go to state 36
    or                             shift and go to state 37
    while_stmt                     shift and go to state 39
    shift                          shift and go to state 40
    op                             shift and go to state 66
    assign                         shift and go to state 38
    cmp                            shift and go to state 43

state 20

    (69) shift -> arith .
    (71) arith -> arith . PLUS term
    (72) arith -> arith . MINUS term

    BAND            reduce using rule 69 (shift -> arith .)
    SHIFTLEFT       reduce using rule 69 (shift -> arith .)
    SHIFTRIGTH      reduce using rule 69 (shift -> arith .)
    BXOR            reduce using rule 69 (shift -> arith .)
    BOR             reduce using rule 69 (shift -> arith .)
    LT              reduce using rule 69 (shift -> arith .)
    GT              reduce using rule 69 (shift -> arith .)
    LE              reduce using rule 69 (shift -> arith .)
    GE              reduce using rule 69 (shift -> arith .)
    NE              reduce using rule 69 (shift -> arith .)
    DEQUAL          reduce using rule 69 (shift -> arith .)
    AND             reduce using rule 69 (shift -> arith .)
    OR              reduce using rule 69 (shift -> arith .)
    SEMICOLON       reduce using rule 69 (shift -> arith .)
    THEN            reduce using rule 69 (shift -> arith .)
    RPAR            reduce using rule 69 (shift -> arith .)
    COMMA           reduce using rule 69 (shift -> arith .)
    RSQB            reduce using rule 69 (shift -> arith .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68


state 21

    (48) expr -> index_expr .
    (42) assign_left -> index_expr .

    SEMICOLON       reduce using rule 48 (expr -> index_expr .)
    EQUAL           reduce using rule 42 (assign_left -> index_expr .)
    PE              reduce using rule 42 (assign_left -> index_expr .)
    ME              reduce using rule 42 (assign_left -> index_expr .)
    SE              reduce using rule 42 (assign_left -> index_expr .)
    DSE             reduce using rule 42 (assign_left -> index_expr .)
    AE              reduce using rule 42 (assign_left -> index_expr .)
    DAE             reduce using rule 42 (assign_left -> index_expr .)


state 22

    (90) primary -> STRING .

    MUL             reduce using rule 90 (primary -> STRING .)
    DIV             reduce using rule 90 (primary -> STRING .)
    MOD             reduce using rule 90 (primary -> STRING .)
    POW             reduce using rule 90 (primary -> STRING .)
    DIV2            reduce using rule 90 (primary -> STRING .)
    PLUS            reduce using rule 90 (primary -> STRING .)
    MINUS           reduce using rule 90 (primary -> STRING .)
    BAND            reduce using rule 90 (primary -> STRING .)
    SHIFTLEFT       reduce using rule 90 (primary -> STRING .)
    SHIFTRIGTH      reduce using rule 90 (primary -> STRING .)
    BXOR            reduce using rule 90 (primary -> STRING .)
    BOR             reduce using rule 90 (primary -> STRING .)
    LT              reduce using rule 90 (primary -> STRING .)
    GT              reduce using rule 90 (primary -> STRING .)
    LE              reduce using rule 90 (primary -> STRING .)
    GE              reduce using rule 90 (primary -> STRING .)
    NE              reduce using rule 90 (primary -> STRING .)
    DEQUAL          reduce using rule 90 (primary -> STRING .)
    AND             reduce using rule 90 (primary -> STRING .)
    OR              reduce using rule 90 (primary -> STRING .)
    SEMICOLON       reduce using rule 90 (primary -> STRING .)
    THEN            reduce using rule 90 (primary -> STRING .)
    RPAR            reduce using rule 90 (primary -> STRING .)
    COMMA           reduce using rule 90 (primary -> STRING .)
    RSQB            reduce using rule 90 (primary -> STRING .)


state 23

    (24) for_stmt -> FOR . LPAR assign SEMICOLON expr SEMICOLON expr RPAR code_block
    (25) for_stmt -> FOR . LPAR expr SEMICOLON expr SEMICOLON expr RPAR THEN code_block

    LPAR            shift and go to state 69


state 24

    (9) stmt -> call_stmt .
    (86) atom -> call_stmt .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 9 (stmt -> call_stmt .)
    SEMICOLON       reduce using rule 9 (stmt -> call_stmt .)
    MUL             reduce using rule 86 (atom -> call_stmt .)
    DIV             reduce using rule 86 (atom -> call_stmt .)
    MOD             reduce using rule 86 (atom -> call_stmt .)
    POW             reduce using rule 86 (atom -> call_stmt .)
    DIV2            reduce using rule 86 (atom -> call_stmt .)
    PLUS            reduce using rule 86 (atom -> call_stmt .)
    MINUS           reduce using rule 86 (atom -> call_stmt .)
    BAND            reduce using rule 86 (atom -> call_stmt .)
    SHIFTLEFT       reduce using rule 86 (atom -> call_stmt .)
    SHIFTRIGTH      reduce using rule 86 (atom -> call_stmt .)
    BXOR            reduce using rule 86 (atom -> call_stmt .)
    BOR             reduce using rule 86 (atom -> call_stmt .)
    LT              reduce using rule 86 (atom -> call_stmt .)
    GT              reduce using rule 86 (atom -> call_stmt .)
    LE              reduce using rule 86 (atom -> call_stmt .)
    GE              reduce using rule 86 (atom -> call_stmt .)
    NE              reduce using rule 86 (atom -> call_stmt .)
    DEQUAL          reduce using rule 86 (atom -> call_stmt .)
    AND             reduce using rule 86 (atom -> call_stmt .)
    OR              reduce using rule 86 (atom -> call_stmt .)

  ! SEMICOLON       [ reduce using rule 86 (atom -> call_stmt .) ]


state 25

    (47) expr -> return_expr .

    SEMICOLON       reduce using rule 47 (expr -> return_expr .)
    RPAR            reduce using rule 47 (expr -> return_expr .)
    COMMA           reduce using rule 47 (expr -> return_expr .)
    THEN            reduce using rule 47 (expr -> return_expr .)
    RSQB            reduce using rule 47 (expr -> return_expr .)


state 26

    (85) atom -> primary .

    MUL             reduce using rule 85 (atom -> primary .)
    DIV             reduce using rule 85 (atom -> primary .)
    MOD             reduce using rule 85 (atom -> primary .)
    POW             reduce using rule 85 (atom -> primary .)
    DIV2            reduce using rule 85 (atom -> primary .)
    PLUS            reduce using rule 85 (atom -> primary .)
    MINUS           reduce using rule 85 (atom -> primary .)
    BAND            reduce using rule 85 (atom -> primary .)
    SHIFTLEFT       reduce using rule 85 (atom -> primary .)
    SHIFTRIGTH      reduce using rule 85 (atom -> primary .)
    BXOR            reduce using rule 85 (atom -> primary .)
    BOR             reduce using rule 85 (atom -> primary .)
    LT              reduce using rule 85 (atom -> primary .)
    GT              reduce using rule 85 (atom -> primary .)
    LE              reduce using rule 85 (atom -> primary .)
    GE              reduce using rule 85 (atom -> primary .)
    NE              reduce using rule 85 (atom -> primary .)
    DEQUAL          reduce using rule 85 (atom -> primary .)
    AND             reduce using rule 85 (atom -> primary .)
    OR              reduce using rule 85 (atom -> primary .)
    SEMICOLON       reduce using rule 85 (atom -> primary .)
    THEN            reduce using rule 85 (atom -> primary .)
    RPAR            reduce using rule 85 (atom -> primary .)
    COMMA           reduce using rule 85 (atom -> primary .)
    RSQB            reduce using rule 85 (atom -> primary .)


state 27

    (6) op -> stmt . SEMICOLON

    SEMICOLON       shift and go to state 70


state 28

    (11) stmt -> for_stmt .

    SEMICOLON       reduce using rule 11 (stmt -> for_stmt .)


state 29

    (80) factor -> atom .

    MUL             reduce using rule 80 (factor -> atom .)
    DIV             reduce using rule 80 (factor -> atom .)
    MOD             reduce using rule 80 (factor -> atom .)
    POW             reduce using rule 80 (factor -> atom .)
    DIV2            reduce using rule 80 (factor -> atom .)
    PLUS            reduce using rule 80 (factor -> atom .)
    MINUS           reduce using rule 80 (factor -> atom .)
    BAND            reduce using rule 80 (factor -> atom .)
    SHIFTLEFT       reduce using rule 80 (factor -> atom .)
    SHIFTRIGTH      reduce using rule 80 (factor -> atom .)
    BXOR            reduce using rule 80 (factor -> atom .)
    BOR             reduce using rule 80 (factor -> atom .)
    LT              reduce using rule 80 (factor -> atom .)
    GT              reduce using rule 80 (factor -> atom .)
    LE              reduce using rule 80 (factor -> atom .)
    GE              reduce using rule 80 (factor -> atom .)
    NE              reduce using rule 80 (factor -> atom .)
    DEQUAL          reduce using rule 80 (factor -> atom .)
    AND             reduce using rule 80 (factor -> atom .)
    OR              reduce using rule 80 (factor -> atom .)
    SEMICOLON       reduce using rule 80 (factor -> atom .)
    THEN            reduce using rule 80 (factor -> atom .)
    RPAR            reduce using rule 80 (factor -> atom .)
    COMMA           reduce using rule 80 (factor -> atom .)
    RSQB            reduce using rule 80 (factor -> atom .)


state 30

    (92) list_def -> LSQB . RSQB
    (93) list_def -> LSQB . primary_list RSQB
    (94) primary_list -> . primary
    (95) primary_list -> . primary_list COMMA primary
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    RSQB            shift and go to state 73
    ID              shift and go to state 74
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    list_def                       shift and go to state 13
    primary_list                   shift and go to state 71
    primary                        shift and go to state 72

state 31

    (49) index_expr -> ID . LSQB expr RSQB
    (31) call_stmt -> ID . LPAR RPAR
    (32) call_stmt -> ID . LPAR args_list RPAR
    (33) assign -> ID . TYPEIS type EQUAL expr
    (41) assign_left -> ID .
    (87) primary -> ID .

    LSQB            shift and go to state 77
    LPAR            shift and go to state 75
    TYPEIS          shift and go to state 76
    EQUAL           reduce using rule 41 (assign_left -> ID .)
    PE              reduce using rule 41 (assign_left -> ID .)
    ME              reduce using rule 41 (assign_left -> ID .)
    SE              reduce using rule 41 (assign_left -> ID .)
    DSE             reduce using rule 41 (assign_left -> ID .)
    AE              reduce using rule 41 (assign_left -> ID .)
    DAE             reduce using rule 41 (assign_left -> ID .)
    MUL             reduce using rule 87 (primary -> ID .)
    DIV             reduce using rule 87 (primary -> ID .)
    MOD             reduce using rule 87 (primary -> ID .)
    POW             reduce using rule 87 (primary -> ID .)
    DIV2            reduce using rule 87 (primary -> ID .)
    PLUS            reduce using rule 87 (primary -> ID .)
    MINUS           reduce using rule 87 (primary -> ID .)
    BAND            reduce using rule 87 (primary -> ID .)
    SHIFTLEFT       reduce using rule 87 (primary -> ID .)
    SHIFTRIGTH      reduce using rule 87 (primary -> ID .)
    BXOR            reduce using rule 87 (primary -> ID .)
    BOR             reduce using rule 87 (primary -> ID .)
    LT              reduce using rule 87 (primary -> ID .)
    GT              reduce using rule 87 (primary -> ID .)
    LE              reduce using rule 87 (primary -> ID .)
    GE              reduce using rule 87 (primary -> ID .)
    NE              reduce using rule 87 (primary -> ID .)
    DEQUAL          reduce using rule 87 (primary -> ID .)
    AND             reduce using rule 87 (primary -> ID .)
    OR              reduce using rule 87 (primary -> ID .)
    SEMICOLON       reduce using rule 87 (primary -> ID .)


state 32

    (88) primary -> NUMBER .

    MUL             reduce using rule 88 (primary -> NUMBER .)
    DIV             reduce using rule 88 (primary -> NUMBER .)
    MOD             reduce using rule 88 (primary -> NUMBER .)
    POW             reduce using rule 88 (primary -> NUMBER .)
    DIV2            reduce using rule 88 (primary -> NUMBER .)
    PLUS            reduce using rule 88 (primary -> NUMBER .)
    MINUS           reduce using rule 88 (primary -> NUMBER .)
    BAND            reduce using rule 88 (primary -> NUMBER .)
    SHIFTLEFT       reduce using rule 88 (primary -> NUMBER .)
    SHIFTRIGTH      reduce using rule 88 (primary -> NUMBER .)
    BXOR            reduce using rule 88 (primary -> NUMBER .)
    BOR             reduce using rule 88 (primary -> NUMBER .)
    LT              reduce using rule 88 (primary -> NUMBER .)
    GT              reduce using rule 88 (primary -> NUMBER .)
    LE              reduce using rule 88 (primary -> NUMBER .)
    GE              reduce using rule 88 (primary -> NUMBER .)
    NE              reduce using rule 88 (primary -> NUMBER .)
    DEQUAL          reduce using rule 88 (primary -> NUMBER .)
    AND             reduce using rule 88 (primary -> NUMBER .)
    OR              reduce using rule 88 (primary -> NUMBER .)
    SEMICOLON       reduce using rule 88 (primary -> NUMBER .)
    THEN            reduce using rule 88 (primary -> NUMBER .)
    RPAR            reduce using rule 88 (primary -> NUMBER .)
    COMMA           reduce using rule 88 (primary -> NUMBER .)
    RSQB            reduce using rule 88 (primary -> NUMBER .)


state 33

    (13) if_stmt -> IF . expr THEN code_block elseifs_stmts else_stmt
    (14) if_stmt -> IF . LPAR expr RPAR code_block elseifs_stmts else_stmt
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 78
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    par_expr                       shift and go to state 6
    primary                        shift and go to state 26
    cmp_expr                       shift and go to state 17
    xor                            shift and go to state 12
    list_def                       shift and go to state 13
    factor                         shift and go to state 5
    test                           shift and go to state 18
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    call_stmt                      shift and go to state 48
    return_expr                    shift and go to state 25
    atom                           shift and go to state 29
    term                           shift and go to state 34
    expr                           shift and go to state 81
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp                            shift and go to state 43

state 34

    (73) arith -> term .
    (74) term -> term . MUL factor
    (75) term -> term . DIV factor
    (76) term -> term . MOD factor
    (77) term -> term . POW factor
    (78) term -> term . DIV2 factor

    PLUS            reduce using rule 73 (arith -> term .)
    MINUS           reduce using rule 73 (arith -> term .)
    BAND            reduce using rule 73 (arith -> term .)
    SHIFTLEFT       reduce using rule 73 (arith -> term .)
    SHIFTRIGTH      reduce using rule 73 (arith -> term .)
    BXOR            reduce using rule 73 (arith -> term .)
    BOR             reduce using rule 73 (arith -> term .)
    LT              reduce using rule 73 (arith -> term .)
    GT              reduce using rule 73 (arith -> term .)
    LE              reduce using rule 73 (arith -> term .)
    GE              reduce using rule 73 (arith -> term .)
    NE              reduce using rule 73 (arith -> term .)
    DEQUAL          reduce using rule 73 (arith -> term .)
    AND             reduce using rule 73 (arith -> term .)
    OR              reduce using rule 73 (arith -> term .)
    SEMICOLON       reduce using rule 73 (arith -> term .)
    THEN            reduce using rule 73 (arith -> term .)
    RPAR            reduce using rule 73 (arith -> term .)
    COMMA           reduce using rule 73 (arith -> term .)
    RSQB            reduce using rule 73 (arith -> term .)
    MUL             shift and go to state 83
    DIV             shift and go to state 84
    MOD             shift and go to state 86
    POW             shift and go to state 82
    DIV2            shift and go to state 85


state 35

    (8) stmt -> if_stmt .

    SEMICOLON       reduce using rule 8 (stmt -> if_stmt .)


state 36

    (5) op -> expr . SEMICOLON

    SEMICOLON       shift and go to state 87


state 37

    (60) cmp_expr -> or .
    (61) or -> or . BOR xor

    LT              reduce using rule 60 (cmp_expr -> or .)
    GT              reduce using rule 60 (cmp_expr -> or .)
    LE              reduce using rule 60 (cmp_expr -> or .)
    GE              reduce using rule 60 (cmp_expr -> or .)
    NE              reduce using rule 60 (cmp_expr -> or .)
    DEQUAL          reduce using rule 60 (cmp_expr -> or .)
    AND             reduce using rule 60 (cmp_expr -> or .)
    OR              reduce using rule 60 (cmp_expr -> or .)
    SEMICOLON       reduce using rule 60 (cmp_expr -> or .)
    THEN            reduce using rule 60 (cmp_expr -> or .)
    RPAR            reduce using rule 60 (cmp_expr -> or .)
    COMMA           reduce using rule 60 (cmp_expr -> or .)
    RSQB            reduce using rule 60 (cmp_expr -> or .)
    BOR             shift and go to state 88


state 38

    (12) stmt -> assign .

    SEMICOLON       reduce using rule 12 (stmt -> assign .)


state 39

    (10) stmt -> while_stmt .

    SEMICOLON       reduce using rule 10 (stmt -> while_stmt .)


state 40

    (66) and -> shift .

    BAND            reduce using rule 66 (and -> shift .)
    SHIFTLEFT       reduce using rule 66 (and -> shift .)
    SHIFTRIGTH      reduce using rule 66 (and -> shift .)
    BXOR            reduce using rule 66 (and -> shift .)
    BOR             reduce using rule 66 (and -> shift .)
    LT              reduce using rule 66 (and -> shift .)
    GT              reduce using rule 66 (and -> shift .)
    LE              reduce using rule 66 (and -> shift .)
    GE              reduce using rule 66 (and -> shift .)
    NE              reduce using rule 66 (and -> shift .)
    DEQUAL          reduce using rule 66 (and -> shift .)
    AND             reduce using rule 66 (and -> shift .)
    OR              reduce using rule 66 (and -> shift .)
    SEMICOLON       reduce using rule 66 (and -> shift .)
    THEN            reduce using rule 66 (and -> shift .)
    RPAR            reduce using rule 66 (and -> shift .)
    COMMA           reduce using rule 66 (and -> shift .)
    RSQB            reduce using rule 66 (and -> shift .)


state 41

    (84) factor -> NOT . atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    call_stmt                      shift and go to state 48
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 89

state 42

    (2) input -> op .

    RBRACE          reduce using rule 2 (input -> op .)
    LPAR            reduce using rule 2 (input -> op .)
    RETURN          reduce using rule 2 (input -> op .)
    ID              reduce using rule 2 (input -> op .)
    DEF             reduce using rule 2 (input -> op .)
    IF              reduce using rule 2 (input -> op .)
    WHILE           reduce using rule 2 (input -> op .)
    FOR             reduce using rule 2 (input -> op .)
    EMARK           reduce using rule 2 (input -> op .)
    MINUS           reduce using rule 2 (input -> op .)
    PLUS            reduce using rule 2 (input -> op .)
    NOT             reduce using rule 2 (input -> op .)
    NUMBER          reduce using rule 2 (input -> op .)
    FLOAT           reduce using rule 2 (input -> op .)
    STRING          reduce using rule 2 (input -> op .)
    LSQB            reduce using rule 2 (input -> op .)
    $end            reduce using rule 2 (input -> op .)


state 43

    (52) test -> cmp .
    (53) cmp -> cmp . LT cmp_expr
    (54) cmp -> cmp . GT cmp_expr
    (55) cmp -> cmp . LE cmp_expr
    (56) cmp -> cmp . GE cmp_expr
    (57) cmp -> cmp . NE cmp_expr
    (58) cmp -> cmp . DEQUAL cmp_expr

    AND             reduce using rule 52 (test -> cmp .)
    OR              reduce using rule 52 (test -> cmp .)
    SEMICOLON       reduce using rule 52 (test -> cmp .)
    RPAR            reduce using rule 52 (test -> cmp .)
    THEN            reduce using rule 52 (test -> cmp .)
    COMMA           reduce using rule 52 (test -> cmp .)
    RSQB            reduce using rule 52 (test -> cmp .)
    LT              shift and go to state 94
    GT              shift and go to state 90
    LE              shift and go to state 95
    GE              shift and go to state 92
    NE              shift and go to state 93
    DEQUAL          shift and go to state 91


state 44

    (65) and -> and BAND . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (65) and -> . and BAND shift
    (66) and -> . shift
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 96
    term                           shift and go to state 34
    arith                          shift and go to state 20
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 97
    factor                         shift and go to state 5
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 45

    (68) shift -> and SHIFTRIGTH . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (65) and -> . and BAND shift
    (66) and -> . shift
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 96
    term                           shift and go to state 34
    arith                          shift and go to state 20
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 98
    factor                         shift and go to state 5
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 46

    (67) shift -> and SHIFTLEFT . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (65) and -> . and BAND shift
    (66) and -> . shift
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 96
    term                           shift and go to state 34
    arith                          shift and go to state 20
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 99
    factor                         shift and go to state 5
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 47

    (70) par_expr -> LPAR arith . RPAR
    (71) arith -> arith . PLUS term
    (72) arith -> arith . MINUS term

    RPAR            shift and go to state 100
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68


state 48

    (86) atom -> call_stmt .

    MUL             reduce using rule 86 (atom -> call_stmt .)
    DIV             reduce using rule 86 (atom -> call_stmt .)
    MOD             reduce using rule 86 (atom -> call_stmt .)
    POW             reduce using rule 86 (atom -> call_stmt .)
    DIV2            reduce using rule 86 (atom -> call_stmt .)
    PLUS            reduce using rule 86 (atom -> call_stmt .)
    MINUS           reduce using rule 86 (atom -> call_stmt .)
    BAND            reduce using rule 86 (atom -> call_stmt .)
    SHIFTLEFT       reduce using rule 86 (atom -> call_stmt .)
    SHIFTRIGTH      reduce using rule 86 (atom -> call_stmt .)
    BXOR            reduce using rule 86 (atom -> call_stmt .)
    BOR             reduce using rule 86 (atom -> call_stmt .)
    LT              reduce using rule 86 (atom -> call_stmt .)
    GT              reduce using rule 86 (atom -> call_stmt .)
    LE              reduce using rule 86 (atom -> call_stmt .)
    GE              reduce using rule 86 (atom -> call_stmt .)
    NE              reduce using rule 86 (atom -> call_stmt .)
    DEQUAL          reduce using rule 86 (atom -> call_stmt .)
    AND             reduce using rule 86 (atom -> call_stmt .)
    OR              reduce using rule 86 (atom -> call_stmt .)
    SEMICOLON       reduce using rule 86 (atom -> call_stmt .)
    THEN            reduce using rule 86 (atom -> call_stmt .)
    RPAR            reduce using rule 86 (atom -> call_stmt .)
    COMMA           reduce using rule 86 (atom -> call_stmt .)
    RSQB            reduce using rule 86 (atom -> call_stmt .)


state 49

    (87) primary -> ID .
    (31) call_stmt -> ID . LPAR RPAR
    (32) call_stmt -> ID . LPAR args_list RPAR

    MUL             reduce using rule 87 (primary -> ID .)
    DIV             reduce using rule 87 (primary -> ID .)
    MOD             reduce using rule 87 (primary -> ID .)
    POW             reduce using rule 87 (primary -> ID .)
    DIV2            reduce using rule 87 (primary -> ID .)
    PLUS            reduce using rule 87 (primary -> ID .)
    MINUS           reduce using rule 87 (primary -> ID .)
    BAND            reduce using rule 87 (primary -> ID .)
    SHIFTLEFT       reduce using rule 87 (primary -> ID .)
    SHIFTRIGTH      reduce using rule 87 (primary -> ID .)
    BXOR            reduce using rule 87 (primary -> ID .)
    BOR             reduce using rule 87 (primary -> ID .)
    LT              reduce using rule 87 (primary -> ID .)
    GT              reduce using rule 87 (primary -> ID .)
    LE              reduce using rule 87 (primary -> ID .)
    GE              reduce using rule 87 (primary -> ID .)
    NE              reduce using rule 87 (primary -> ID .)
    DEQUAL          reduce using rule 87 (primary -> ID .)
    AND             reduce using rule 87 (primary -> ID .)
    OR              reduce using rule 87 (primary -> ID .)
    SEMICOLON       reduce using rule 87 (primary -> ID .)
    THEN            reduce using rule 87 (primary -> ID .)
    RPAR            reduce using rule 87 (primary -> ID .)
    COMMA           reduce using rule 87 (primary -> ID .)
    RSQB            reduce using rule 87 (primary -> ID .)
    LPAR            shift and go to state 75


state 50

    (105) return_expr -> RETURN test .
    (50) test -> test . AND cmp
    (51) test -> test . OR cmp

    SEMICOLON       reduce using rule 105 (return_expr -> RETURN test .)
    THEN            reduce using rule 105 (return_expr -> RETURN test .)
    RPAR            reduce using rule 105 (return_expr -> RETURN test .)
    RSQB            reduce using rule 105 (return_expr -> RETURN test .)
    COMMA           reduce using rule 105 (return_expr -> RETURN test .)
    AND             shift and go to state 64
    OR              shift and go to state 65


state 51

    (22) while_stmt -> WHILE LPAR . expr RPAR code_block
    (23) while_stmt -> WHILE LPAR . expr RPAR THEN code_block
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 101
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    arith                          shift and go to state 20
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 52

    (36) assign -> assign_left ME . expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 102
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 53

    (40) assign -> assign_left DAE . expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 103
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 54

    (39) assign -> assign_left AE . expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 104
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 55

    (34) assign -> assign_left EQUAL . expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 105
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 56

    (35) assign -> assign_left PE . expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 106
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 57

    (38) assign -> assign_left DSE . expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 107
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 58

    (37) assign -> assign_left SE . expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 108
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 59

    (81) factor -> EMARK atom .

    MUL             reduce using rule 81 (factor -> EMARK atom .)
    DIV             reduce using rule 81 (factor -> EMARK atom .)
    MOD             reduce using rule 81 (factor -> EMARK atom .)
    POW             reduce using rule 81 (factor -> EMARK atom .)
    DIV2            reduce using rule 81 (factor -> EMARK atom .)
    PLUS            reduce using rule 81 (factor -> EMARK atom .)
    MINUS           reduce using rule 81 (factor -> EMARK atom .)
    BAND            reduce using rule 81 (factor -> EMARK atom .)
    SHIFTLEFT       reduce using rule 81 (factor -> EMARK atom .)
    SHIFTRIGTH      reduce using rule 81 (factor -> EMARK atom .)
    BXOR            reduce using rule 81 (factor -> EMARK atom .)
    BOR             reduce using rule 81 (factor -> EMARK atom .)
    LT              reduce using rule 81 (factor -> EMARK atom .)
    GT              reduce using rule 81 (factor -> EMARK atom .)
    LE              reduce using rule 81 (factor -> EMARK atom .)
    GE              reduce using rule 81 (factor -> EMARK atom .)
    NE              reduce using rule 81 (factor -> EMARK atom .)
    DEQUAL          reduce using rule 81 (factor -> EMARK atom .)
    AND             reduce using rule 81 (factor -> EMARK atom .)
    OR              reduce using rule 81 (factor -> EMARK atom .)
    SEMICOLON       reduce using rule 81 (factor -> EMARK atom .)
    THEN            reduce using rule 81 (factor -> EMARK atom .)
    RPAR            reduce using rule 81 (factor -> EMARK atom .)
    COMMA           reduce using rule 81 (factor -> EMARK atom .)
    RSQB            reduce using rule 81 (factor -> EMARK atom .)


state 60

    (26) def_stmt -> DEF ID . LPAR var_prototypes_list RPAR TYPEIS type THEN code_block
    (27) def_stmt -> DEF ID . LPAR var_prototypes_list RPAR TYPEIS type code_block

    LPAR            shift and go to state 109


state 61

    (63) xor -> xor BXOR . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 110
    term                           shift and go to state 34
    arith                          shift and go to state 20
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5

state 62

    (82) factor -> MINUS atom .

    MUL             reduce using rule 82 (factor -> MINUS atom .)
    DIV             reduce using rule 82 (factor -> MINUS atom .)
    MOD             reduce using rule 82 (factor -> MINUS atom .)
    POW             reduce using rule 82 (factor -> MINUS atom .)
    DIV2            reduce using rule 82 (factor -> MINUS atom .)
    PLUS            reduce using rule 82 (factor -> MINUS atom .)
    MINUS           reduce using rule 82 (factor -> MINUS atom .)
    BAND            reduce using rule 82 (factor -> MINUS atom .)
    SHIFTLEFT       reduce using rule 82 (factor -> MINUS atom .)
    SHIFTRIGTH      reduce using rule 82 (factor -> MINUS atom .)
    BXOR            reduce using rule 82 (factor -> MINUS atom .)
    BOR             reduce using rule 82 (factor -> MINUS atom .)
    LT              reduce using rule 82 (factor -> MINUS atom .)
    GT              reduce using rule 82 (factor -> MINUS atom .)
    LE              reduce using rule 82 (factor -> MINUS atom .)
    GE              reduce using rule 82 (factor -> MINUS atom .)
    NE              reduce using rule 82 (factor -> MINUS atom .)
    DEQUAL          reduce using rule 82 (factor -> MINUS atom .)
    AND             reduce using rule 82 (factor -> MINUS atom .)
    OR              reduce using rule 82 (factor -> MINUS atom .)
    SEMICOLON       reduce using rule 82 (factor -> MINUS atom .)
    THEN            reduce using rule 82 (factor -> MINUS atom .)
    RPAR            reduce using rule 82 (factor -> MINUS atom .)
    COMMA           reduce using rule 82 (factor -> MINUS atom .)
    RSQB            reduce using rule 82 (factor -> MINUS atom .)


state 63

    (83) factor -> PLUS atom .

    MUL             reduce using rule 83 (factor -> PLUS atom .)
    DIV             reduce using rule 83 (factor -> PLUS atom .)
    MOD             reduce using rule 83 (factor -> PLUS atom .)
    POW             reduce using rule 83 (factor -> PLUS atom .)
    DIV2            reduce using rule 83 (factor -> PLUS atom .)
    PLUS            reduce using rule 83 (factor -> PLUS atom .)
    MINUS           reduce using rule 83 (factor -> PLUS atom .)
    BAND            reduce using rule 83 (factor -> PLUS atom .)
    SHIFTLEFT       reduce using rule 83 (factor -> PLUS atom .)
    SHIFTRIGTH      reduce using rule 83 (factor -> PLUS atom .)
    BXOR            reduce using rule 83 (factor -> PLUS atom .)
    BOR             reduce using rule 83 (factor -> PLUS atom .)
    LT              reduce using rule 83 (factor -> PLUS atom .)
    GT              reduce using rule 83 (factor -> PLUS atom .)
    LE              reduce using rule 83 (factor -> PLUS atom .)
    GE              reduce using rule 83 (factor -> PLUS atom .)
    NE              reduce using rule 83 (factor -> PLUS atom .)
    DEQUAL          reduce using rule 83 (factor -> PLUS atom .)
    AND             reduce using rule 83 (factor -> PLUS atom .)
    OR              reduce using rule 83 (factor -> PLUS atom .)
    SEMICOLON       reduce using rule 83 (factor -> PLUS atom .)
    THEN            reduce using rule 83 (factor -> PLUS atom .)
    RPAR            reduce using rule 83 (factor -> PLUS atom .)
    COMMA           reduce using rule 83 (factor -> PLUS atom .)
    RSQB            reduce using rule 83 (factor -> PLUS atom .)


state 64

    (50) test -> test AND . cmp
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    xor                            shift and go to state 12
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 111

state 65

    (51) test -> test OR . cmp
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    xor                            shift and go to state 12
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 112

state 66

    (3) input -> input op .

    RBRACE          reduce using rule 3 (input -> input op .)
    LPAR            reduce using rule 3 (input -> input op .)
    RETURN          reduce using rule 3 (input -> input op .)
    ID              reduce using rule 3 (input -> input op .)
    DEF             reduce using rule 3 (input -> input op .)
    IF              reduce using rule 3 (input -> input op .)
    WHILE           reduce using rule 3 (input -> input op .)
    FOR             reduce using rule 3 (input -> input op .)
    EMARK           reduce using rule 3 (input -> input op .)
    MINUS           reduce using rule 3 (input -> input op .)
    PLUS            reduce using rule 3 (input -> input op .)
    NOT             reduce using rule 3 (input -> input op .)
    NUMBER          reduce using rule 3 (input -> input op .)
    FLOAT           reduce using rule 3 (input -> input op .)
    STRING          reduce using rule 3 (input -> input op .)
    LSQB            reduce using rule 3 (input -> input op .)
    $end            reduce using rule 3 (input -> input op .)


state 67

    (71) arith -> arith PLUS . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    term                           shift and go to state 113
    call_stmt                      shift and go to state 48
    factor                         shift and go to state 5
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 68

    (72) arith -> arith MINUS . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    term                           shift and go to state 114
    call_stmt                      shift and go to state 48
    factor                         shift and go to state 5
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 69

    (24) for_stmt -> FOR LPAR . assign SEMICOLON expr SEMICOLON expr RPAR code_block
    (25) for_stmt -> FOR LPAR . expr SEMICOLON expr SEMICOLON expr RPAR THEN code_block
    (33) assign -> . ID TYPEIS type EQUAL expr
    (34) assign -> . assign_left EQUAL expr
    (35) assign -> . assign_left PE expr
    (36) assign -> . assign_left ME expr
    (37) assign -> . assign_left SE expr
    (38) assign -> . assign_left DSE expr
    (39) assign -> . assign_left AE expr
    (40) assign -> . assign_left DAE expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (41) assign_left -> . ID
    (42) assign_left -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    ID              shift and go to state 115
    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    par_expr                       shift and go to state 6
    primary                        shift and go to state 26
    assign_left                    shift and go to state 9
    cmp_expr                       shift and go to state 17
    xor                            shift and go to state 12
    list_def                       shift and go to state 13
    factor                         shift and go to state 5
    test                           shift and go to state 18
    arith                          shift and go to state 20
    index_expr                     shift and go to state 21
    call_stmt                      shift and go to state 48
    return_expr                    shift and go to state 25
    atom                           shift and go to state 29
    term                           shift and go to state 34
    expr                           shift and go to state 116
    assign                         shift and go to state 117
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp                            shift and go to state 43

state 70

    (6) op -> stmt SEMICOLON .

    LPAR            reduce using rule 6 (op -> stmt SEMICOLON .)
    RETURN          reduce using rule 6 (op -> stmt SEMICOLON .)
    ID              reduce using rule 6 (op -> stmt SEMICOLON .)
    DEF             reduce using rule 6 (op -> stmt SEMICOLON .)
    IF              reduce using rule 6 (op -> stmt SEMICOLON .)
    WHILE           reduce using rule 6 (op -> stmt SEMICOLON .)
    FOR             reduce using rule 6 (op -> stmt SEMICOLON .)
    EMARK           reduce using rule 6 (op -> stmt SEMICOLON .)
    MINUS           reduce using rule 6 (op -> stmt SEMICOLON .)
    PLUS            reduce using rule 6 (op -> stmt SEMICOLON .)
    NOT             reduce using rule 6 (op -> stmt SEMICOLON .)
    NUMBER          reduce using rule 6 (op -> stmt SEMICOLON .)
    FLOAT           reduce using rule 6 (op -> stmt SEMICOLON .)
    STRING          reduce using rule 6 (op -> stmt SEMICOLON .)
    LSQB            reduce using rule 6 (op -> stmt SEMICOLON .)
    $end            reduce using rule 6 (op -> stmt SEMICOLON .)
    RBRACE          reduce using rule 6 (op -> stmt SEMICOLON .)


state 71

    (93) list_def -> LSQB primary_list . RSQB
    (95) primary_list -> primary_list . COMMA primary

    RSQB            shift and go to state 119
    COMMA           shift and go to state 118


state 72

    (94) primary_list -> primary .

    RSQB            reduce using rule 94 (primary_list -> primary .)
    COMMA           reduce using rule 94 (primary_list -> primary .)


state 73

    (92) list_def -> LSQB RSQB .

    MUL             reduce using rule 92 (list_def -> LSQB RSQB .)
    DIV             reduce using rule 92 (list_def -> LSQB RSQB .)
    MOD             reduce using rule 92 (list_def -> LSQB RSQB .)
    POW             reduce using rule 92 (list_def -> LSQB RSQB .)
    DIV2            reduce using rule 92 (list_def -> LSQB RSQB .)
    PLUS            reduce using rule 92 (list_def -> LSQB RSQB .)
    MINUS           reduce using rule 92 (list_def -> LSQB RSQB .)
    BAND            reduce using rule 92 (list_def -> LSQB RSQB .)
    SHIFTLEFT       reduce using rule 92 (list_def -> LSQB RSQB .)
    SHIFTRIGTH      reduce using rule 92 (list_def -> LSQB RSQB .)
    BXOR            reduce using rule 92 (list_def -> LSQB RSQB .)
    BOR             reduce using rule 92 (list_def -> LSQB RSQB .)
    LT              reduce using rule 92 (list_def -> LSQB RSQB .)
    GT              reduce using rule 92 (list_def -> LSQB RSQB .)
    LE              reduce using rule 92 (list_def -> LSQB RSQB .)
    GE              reduce using rule 92 (list_def -> LSQB RSQB .)
    NE              reduce using rule 92 (list_def -> LSQB RSQB .)
    DEQUAL          reduce using rule 92 (list_def -> LSQB RSQB .)
    AND             reduce using rule 92 (list_def -> LSQB RSQB .)
    OR              reduce using rule 92 (list_def -> LSQB RSQB .)
    SEMICOLON       reduce using rule 92 (list_def -> LSQB RSQB .)
    RPAR            reduce using rule 92 (list_def -> LSQB RSQB .)
    THEN            reduce using rule 92 (list_def -> LSQB RSQB .)
    COMMA           reduce using rule 92 (list_def -> LSQB RSQB .)
    RSQB            reduce using rule 92 (list_def -> LSQB RSQB .)


state 74

    (87) primary -> ID .

    RSQB            reduce using rule 87 (primary -> ID .)
    COMMA           reduce using rule 87 (primary -> ID .)


state 75

    (31) call_stmt -> ID LPAR . RPAR
    (32) call_stmt -> ID LPAR . args_list RPAR
    (43) args_list -> . expr
    (44) args_list -> . args_list COMMA expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    RPAR            shift and go to state 120
    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    par_expr                       shift and go to state 6
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    args_list                      shift and go to state 121
    atom                           shift and go to state 29
    expr                           shift and go to state 122
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 76

    (33) assign -> ID TYPEIS . type EQUAL expr
    (96) type -> . TINT
    (97) type -> . TLONG
    (98) type -> . TFLOAT
    (99) type -> . ARRAY
    (100) type -> . TUPLE
    (101) type -> . CINT
    (102) type -> . CLONG
    (103) type -> . CFLOAT

    TINT            shift and go to state 123
    TLONG           shift and go to state 130
    TFLOAT          shift and go to state 128
    ARRAY           shift and go to state 129
    TUPLE           shift and go to state 125
    CINT            shift and go to state 124
    CLONG           shift and go to state 126
    CFLOAT          shift and go to state 127

    type                           shift and go to state 131

state 77

    (49) index_expr -> ID LSQB . expr RSQB
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 132
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 78

    (14) if_stmt -> IF LPAR . expr RPAR code_block elseifs_stmts else_stmt
    (70) par_expr -> LPAR . arith RPAR
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (60) cmp_expr -> . or
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (61) or -> . or BOR xor
    (62) or -> . xor
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    par_expr                       shift and go to state 6
    primary                        shift and go to state 26
    cmp_expr                       shift and go to state 17
    xor                            shift and go to state 12
    list_def                       shift and go to state 13
    factor                         shift and go to state 5
    test                           shift and go to state 18
    arith                          shift and go to state 133
    index_expr                     shift and go to state 79
    call_stmt                      shift and go to state 48
    return_expr                    shift and go to state 25
    atom                           shift and go to state 29
    term                           shift and go to state 34
    expr                           shift and go to state 134
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp                            shift and go to state 43

state 79

    (48) expr -> index_expr .

    SEMICOLON       reduce using rule 48 (expr -> index_expr .)
    RPAR            reduce using rule 48 (expr -> index_expr .)
    COMMA           reduce using rule 48 (expr -> index_expr .)
    THEN            reduce using rule 48 (expr -> index_expr .)
    RSQB            reduce using rule 48 (expr -> index_expr .)


state 80

    (49) index_expr -> ID . LSQB expr RSQB
    (87) primary -> ID .
    (31) call_stmt -> ID . LPAR RPAR
    (32) call_stmt -> ID . LPAR args_list RPAR

    LSQB            shift and go to state 77
    MUL             reduce using rule 87 (primary -> ID .)
    DIV             reduce using rule 87 (primary -> ID .)
    MOD             reduce using rule 87 (primary -> ID .)
    POW             reduce using rule 87 (primary -> ID .)
    DIV2            reduce using rule 87 (primary -> ID .)
    PLUS            reduce using rule 87 (primary -> ID .)
    MINUS           reduce using rule 87 (primary -> ID .)
    BAND            reduce using rule 87 (primary -> ID .)
    SHIFTLEFT       reduce using rule 87 (primary -> ID .)
    SHIFTRIGTH      reduce using rule 87 (primary -> ID .)
    BXOR            reduce using rule 87 (primary -> ID .)
    BOR             reduce using rule 87 (primary -> ID .)
    LT              reduce using rule 87 (primary -> ID .)
    GT              reduce using rule 87 (primary -> ID .)
    LE              reduce using rule 87 (primary -> ID .)
    GE              reduce using rule 87 (primary -> ID .)
    NE              reduce using rule 87 (primary -> ID .)
    DEQUAL          reduce using rule 87 (primary -> ID .)
    AND             reduce using rule 87 (primary -> ID .)
    OR              reduce using rule 87 (primary -> ID .)
    THEN            reduce using rule 87 (primary -> ID .)
    RPAR            reduce using rule 87 (primary -> ID .)
    COMMA           reduce using rule 87 (primary -> ID .)
    SEMICOLON       reduce using rule 87 (primary -> ID .)
    RSQB            reduce using rule 87 (primary -> ID .)
    LPAR            shift and go to state 75


state 81

    (13) if_stmt -> IF expr . THEN code_block elseifs_stmts else_stmt

    THEN            shift and go to state 135


state 82

    (77) term -> term POW . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    call_stmt                      shift and go to state 48
    factor                         shift and go to state 136
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 83

    (74) term -> term MUL . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    call_stmt                      shift and go to state 48
    factor                         shift and go to state 137
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 84

    (75) term -> term DIV . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    call_stmt                      shift and go to state 48
    factor                         shift and go to state 138
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 85

    (78) term -> term DIV2 . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    call_stmt                      shift and go to state 48
    factor                         shift and go to state 139
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 86

    (76) term -> term MOD . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    call_stmt                      shift and go to state 48
    factor                         shift and go to state 140
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29

state 87

    (5) op -> expr SEMICOLON .

    LPAR            reduce using rule 5 (op -> expr SEMICOLON .)
    RETURN          reduce using rule 5 (op -> expr SEMICOLON .)
    ID              reduce using rule 5 (op -> expr SEMICOLON .)
    DEF             reduce using rule 5 (op -> expr SEMICOLON .)
    IF              reduce using rule 5 (op -> expr SEMICOLON .)
    WHILE           reduce using rule 5 (op -> expr SEMICOLON .)
    FOR             reduce using rule 5 (op -> expr SEMICOLON .)
    EMARK           reduce using rule 5 (op -> expr SEMICOLON .)
    MINUS           reduce using rule 5 (op -> expr SEMICOLON .)
    PLUS            reduce using rule 5 (op -> expr SEMICOLON .)
    NOT             reduce using rule 5 (op -> expr SEMICOLON .)
    NUMBER          reduce using rule 5 (op -> expr SEMICOLON .)
    FLOAT           reduce using rule 5 (op -> expr SEMICOLON .)
    STRING          reduce using rule 5 (op -> expr SEMICOLON .)
    LSQB            reduce using rule 5 (op -> expr SEMICOLON .)
    $end            reduce using rule 5 (op -> expr SEMICOLON .)
    RBRACE          reduce using rule 5 (op -> expr SEMICOLON .)


state 88

    (61) or -> or BOR . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    xor                            shift and go to state 141
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5

state 89

    (84) factor -> NOT atom .

    MUL             reduce using rule 84 (factor -> NOT atom .)
    DIV             reduce using rule 84 (factor -> NOT atom .)
    MOD             reduce using rule 84 (factor -> NOT atom .)
    POW             reduce using rule 84 (factor -> NOT atom .)
    DIV2            reduce using rule 84 (factor -> NOT atom .)
    PLUS            reduce using rule 84 (factor -> NOT atom .)
    MINUS           reduce using rule 84 (factor -> NOT atom .)
    BAND            reduce using rule 84 (factor -> NOT atom .)
    SHIFTLEFT       reduce using rule 84 (factor -> NOT atom .)
    SHIFTRIGTH      reduce using rule 84 (factor -> NOT atom .)
    BXOR            reduce using rule 84 (factor -> NOT atom .)
    BOR             reduce using rule 84 (factor -> NOT atom .)
    LT              reduce using rule 84 (factor -> NOT atom .)
    GT              reduce using rule 84 (factor -> NOT atom .)
    LE              reduce using rule 84 (factor -> NOT atom .)
    GE              reduce using rule 84 (factor -> NOT atom .)
    NE              reduce using rule 84 (factor -> NOT atom .)
    DEQUAL          reduce using rule 84 (factor -> NOT atom .)
    AND             reduce using rule 84 (factor -> NOT atom .)
    OR              reduce using rule 84 (factor -> NOT atom .)
    SEMICOLON       reduce using rule 84 (factor -> NOT atom .)
    THEN            reduce using rule 84 (factor -> NOT atom .)
    RPAR            reduce using rule 84 (factor -> NOT atom .)
    COMMA           reduce using rule 84 (factor -> NOT atom .)
    RSQB            reduce using rule 84 (factor -> NOT atom .)


state 90

    (54) cmp -> cmp GT . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    xor                            shift and go to state 12
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 142

state 91

    (58) cmp -> cmp DEQUAL . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    xor                            shift and go to state 12
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 143

state 92

    (56) cmp -> cmp GE . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    xor                            shift and go to state 12
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 144

state 93

    (57) cmp -> cmp NE . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    xor                            shift and go to state 12
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 145

state 94

    (53) cmp -> cmp LT . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    xor                            shift and go to state 12
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 146

state 95

    (55) cmp -> cmp LE . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    ID              shift and go to state 49
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    xor                            shift and go to state 12
    call_stmt                      shift and go to state 48
    shift                          shift and go to state 40
    atom                           shift and go to state 29
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    factor                         shift and go to state 5
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 147

state 96

    (67) shift -> and . SHIFTLEFT shift
    (68) shift -> and . SHIFTRIGTH shift
    (65) and -> and . BAND shift

    SHIFTLEFT       shift and go to state 46
    SHIFTRIGTH      shift and go to state 45
    BAND            shift and go to state 44


state 97

    (65) and -> and BAND shift .
    (66) and -> shift .

  ! reduce/reduce conflict for SHIFTLEFT resolved using rule 65 (and -> and BAND shift .)
  ! reduce/reduce conflict for SHIFTRIGTH resolved using rule 65 (and -> and BAND shift .)
  ! reduce/reduce conflict for BAND resolved using rule 65 (and -> and BAND shift .)
    BAND            reduce using rule 65 (and -> and BAND shift .)
    SHIFTLEFT       reduce using rule 65 (and -> and BAND shift .)
    SHIFTRIGTH      reduce using rule 65 (and -> and BAND shift .)
    BXOR            reduce using rule 65 (and -> and BAND shift .)
    BOR             reduce using rule 65 (and -> and BAND shift .)
    LT              reduce using rule 65 (and -> and BAND shift .)
    GT              reduce using rule 65 (and -> and BAND shift .)
    LE              reduce using rule 65 (and -> and BAND shift .)
    GE              reduce using rule 65 (and -> and BAND shift .)
    NE              reduce using rule 65 (and -> and BAND shift .)
    DEQUAL          reduce using rule 65 (and -> and BAND shift .)
    AND             reduce using rule 65 (and -> and BAND shift .)
    OR              reduce using rule 65 (and -> and BAND shift .)
    SEMICOLON       reduce using rule 65 (and -> and BAND shift .)
    THEN            reduce using rule 65 (and -> and BAND shift .)
    RPAR            reduce using rule 65 (and -> and BAND shift .)
    COMMA           reduce using rule 65 (and -> and BAND shift .)
    RSQB            reduce using rule 65 (and -> and BAND shift .)

  ! SHIFTLEFT       [ reduce using rule 66 (and -> shift .) ]
  ! SHIFTRIGTH      [ reduce using rule 66 (and -> shift .) ]
  ! BAND            [ reduce using rule 66 (and -> shift .) ]


state 98

    (68) shift -> and SHIFTRIGTH shift .
    (66) and -> shift .

  ! reduce/reduce conflict for SHIFTLEFT resolved using rule 66 (and -> shift .)
  ! reduce/reduce conflict for SHIFTRIGTH resolved using rule 66 (and -> shift .)
  ! reduce/reduce conflict for BAND resolved using rule 66 (and -> shift .)
    BXOR            reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    BOR             reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    LT              reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    GT              reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    LE              reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    GE              reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    NE              reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    DEQUAL          reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    AND             reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    OR              reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    SEMICOLON       reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    THEN            reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    RPAR            reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    COMMA           reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    RSQB            reduce using rule 68 (shift -> and SHIFTRIGTH shift .)
    SHIFTLEFT       reduce using rule 66 (and -> shift .)
    SHIFTRIGTH      reduce using rule 66 (and -> shift .)
    BAND            reduce using rule 66 (and -> shift .)

  ! BAND            [ reduce using rule 68 (shift -> and SHIFTRIGTH shift .) ]
  ! SHIFTLEFT       [ reduce using rule 68 (shift -> and SHIFTRIGTH shift .) ]
  ! SHIFTRIGTH      [ reduce using rule 68 (shift -> and SHIFTRIGTH shift .) ]


state 99

    (67) shift -> and SHIFTLEFT shift .
    (66) and -> shift .

  ! reduce/reduce conflict for SHIFTLEFT resolved using rule 66 (and -> shift .)
  ! reduce/reduce conflict for SHIFTRIGTH resolved using rule 66 (and -> shift .)
  ! reduce/reduce conflict for BAND resolved using rule 66 (and -> shift .)
    BXOR            reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    BOR             reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    LT              reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    GT              reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    LE              reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    GE              reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    NE              reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    DEQUAL          reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    AND             reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    OR              reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    SEMICOLON       reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    THEN            reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    RPAR            reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    COMMA           reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    RSQB            reduce using rule 67 (shift -> and SHIFTLEFT shift .)
    SHIFTLEFT       reduce using rule 66 (and -> shift .)
    SHIFTRIGTH      reduce using rule 66 (and -> shift .)
    BAND            reduce using rule 66 (and -> shift .)

  ! BAND            [ reduce using rule 67 (shift -> and SHIFTLEFT shift .) ]
  ! SHIFTLEFT       [ reduce using rule 67 (shift -> and SHIFTLEFT shift .) ]
  ! SHIFTRIGTH      [ reduce using rule 67 (shift -> and SHIFTLEFT shift .) ]


state 100

    (70) par_expr -> LPAR arith RPAR .

    SEMICOLON       reduce using rule 70 (par_expr -> LPAR arith RPAR .)
    RPAR            reduce using rule 70 (par_expr -> LPAR arith RPAR .)
    COMMA           reduce using rule 70 (par_expr -> LPAR arith RPAR .)
    THEN            reduce using rule 70 (par_expr -> LPAR arith RPAR .)
    RSQB            reduce using rule 70 (par_expr -> LPAR arith RPAR .)


state 101

    (22) while_stmt -> WHILE LPAR expr . RPAR code_block
    (23) while_stmt -> WHILE LPAR expr . RPAR THEN code_block

    RPAR            shift and go to state 148


state 102

    (36) assign -> assign_left ME expr .

    SEMICOLON       reduce using rule 36 (assign -> assign_left ME expr .)


state 103

    (40) assign -> assign_left DAE expr .

    SEMICOLON       reduce using rule 40 (assign -> assign_left DAE expr .)


state 104

    (39) assign -> assign_left AE expr .

    SEMICOLON       reduce using rule 39 (assign -> assign_left AE expr .)


state 105

    (34) assign -> assign_left EQUAL expr .

    SEMICOLON       reduce using rule 34 (assign -> assign_left EQUAL expr .)


state 106

    (35) assign -> assign_left PE expr .

    SEMICOLON       reduce using rule 35 (assign -> assign_left PE expr .)


state 107

    (38) assign -> assign_left DSE expr .

    SEMICOLON       reduce using rule 38 (assign -> assign_left DSE expr .)


state 108

    (37) assign -> assign_left SE expr .

    SEMICOLON       reduce using rule 37 (assign -> assign_left SE expr .)


state 109

    (26) def_stmt -> DEF ID LPAR . var_prototypes_list RPAR TYPEIS type THEN code_block
    (27) def_stmt -> DEF ID LPAR . var_prototypes_list RPAR TYPEIS type code_block
    (28) var_prototypes_list -> . var_prototypes_list COMMA var_prototype
    (29) var_prototypes_list -> . var_prototype
    (30) var_prototype -> . ID TYPEIS type

    ID              shift and go to state 151

    var_prototypes_list            shift and go to state 149
    var_prototype                  shift and go to state 150

state 110

    (63) xor -> xor BXOR and .
    (65) and -> and . BAND shift
    (67) shift -> and . SHIFTLEFT shift
    (68) shift -> and . SHIFTRIGTH shift

    BXOR            reduce using rule 63 (xor -> xor BXOR and .)
    BOR             reduce using rule 63 (xor -> xor BXOR and .)
    LT              reduce using rule 63 (xor -> xor BXOR and .)
    GT              reduce using rule 63 (xor -> xor BXOR and .)
    LE              reduce using rule 63 (xor -> xor BXOR and .)
    GE              reduce using rule 63 (xor -> xor BXOR and .)
    NE              reduce using rule 63 (xor -> xor BXOR and .)
    DEQUAL          reduce using rule 63 (xor -> xor BXOR and .)
    AND             reduce using rule 63 (xor -> xor BXOR and .)
    OR              reduce using rule 63 (xor -> xor BXOR and .)
    SEMICOLON       reduce using rule 63 (xor -> xor BXOR and .)
    THEN            reduce using rule 63 (xor -> xor BXOR and .)
    RPAR            reduce using rule 63 (xor -> xor BXOR and .)
    COMMA           reduce using rule 63 (xor -> xor BXOR and .)
    RSQB            reduce using rule 63 (xor -> xor BXOR and .)
    BAND            shift and go to state 44
    SHIFTLEFT       shift and go to state 46
    SHIFTRIGTH      shift and go to state 45


state 111

    (50) test -> test AND cmp .
    (53) cmp -> cmp . LT cmp_expr
    (54) cmp -> cmp . GT cmp_expr
    (55) cmp -> cmp . LE cmp_expr
    (56) cmp -> cmp . GE cmp_expr
    (57) cmp -> cmp . NE cmp_expr
    (58) cmp -> cmp . DEQUAL cmp_expr

    AND             reduce using rule 50 (test -> test AND cmp .)
    OR              reduce using rule 50 (test -> test AND cmp .)
    SEMICOLON       reduce using rule 50 (test -> test AND cmp .)
    RPAR            reduce using rule 50 (test -> test AND cmp .)
    THEN            reduce using rule 50 (test -> test AND cmp .)
    COMMA           reduce using rule 50 (test -> test AND cmp .)
    RSQB            reduce using rule 50 (test -> test AND cmp .)
    LT              shift and go to state 94
    GT              shift and go to state 90
    LE              shift and go to state 95
    GE              shift and go to state 92
    NE              shift and go to state 93
    DEQUAL          shift and go to state 91


state 112

    (51) test -> test OR cmp .
    (53) cmp -> cmp . LT cmp_expr
    (54) cmp -> cmp . GT cmp_expr
    (55) cmp -> cmp . LE cmp_expr
    (56) cmp -> cmp . GE cmp_expr
    (57) cmp -> cmp . NE cmp_expr
    (58) cmp -> cmp . DEQUAL cmp_expr

    AND             reduce using rule 51 (test -> test OR cmp .)
    OR              reduce using rule 51 (test -> test OR cmp .)
    SEMICOLON       reduce using rule 51 (test -> test OR cmp .)
    RPAR            reduce using rule 51 (test -> test OR cmp .)
    THEN            reduce using rule 51 (test -> test OR cmp .)
    COMMA           reduce using rule 51 (test -> test OR cmp .)
    RSQB            reduce using rule 51 (test -> test OR cmp .)
    LT              shift and go to state 94
    GT              shift and go to state 90
    LE              shift and go to state 95
    GE              shift and go to state 92
    NE              shift and go to state 93
    DEQUAL          shift and go to state 91


state 113

    (71) arith -> arith PLUS term .
    (74) term -> term . MUL factor
    (75) term -> term . DIV factor
    (76) term -> term . MOD factor
    (77) term -> term . POW factor
    (78) term -> term . DIV2 factor

    PLUS            reduce using rule 71 (arith -> arith PLUS term .)
    MINUS           reduce using rule 71 (arith -> arith PLUS term .)
    BAND            reduce using rule 71 (arith -> arith PLUS term .)
    SHIFTLEFT       reduce using rule 71 (arith -> arith PLUS term .)
    SHIFTRIGTH      reduce using rule 71 (arith -> arith PLUS term .)
    BXOR            reduce using rule 71 (arith -> arith PLUS term .)
    BOR             reduce using rule 71 (arith -> arith PLUS term .)
    LT              reduce using rule 71 (arith -> arith PLUS term .)
    GT              reduce using rule 71 (arith -> arith PLUS term .)
    LE              reduce using rule 71 (arith -> arith PLUS term .)
    GE              reduce using rule 71 (arith -> arith PLUS term .)
    NE              reduce using rule 71 (arith -> arith PLUS term .)
    DEQUAL          reduce using rule 71 (arith -> arith PLUS term .)
    AND             reduce using rule 71 (arith -> arith PLUS term .)
    OR              reduce using rule 71 (arith -> arith PLUS term .)
    SEMICOLON       reduce using rule 71 (arith -> arith PLUS term .)
    THEN            reduce using rule 71 (arith -> arith PLUS term .)
    RPAR            reduce using rule 71 (arith -> arith PLUS term .)
    COMMA           reduce using rule 71 (arith -> arith PLUS term .)
    RSQB            reduce using rule 71 (arith -> arith PLUS term .)
    MUL             shift and go to state 83
    DIV             shift and go to state 84
    MOD             shift and go to state 86
    POW             shift and go to state 82
    DIV2            shift and go to state 85


state 114

    (72) arith -> arith MINUS term .
    (74) term -> term . MUL factor
    (75) term -> term . DIV factor
    (76) term -> term . MOD factor
    (77) term -> term . POW factor
    (78) term -> term . DIV2 factor

    PLUS            reduce using rule 72 (arith -> arith MINUS term .)
    MINUS           reduce using rule 72 (arith -> arith MINUS term .)
    BAND            reduce using rule 72 (arith -> arith MINUS term .)
    SHIFTLEFT       reduce using rule 72 (arith -> arith MINUS term .)
    SHIFTRIGTH      reduce using rule 72 (arith -> arith MINUS term .)
    BXOR            reduce using rule 72 (arith -> arith MINUS term .)
    BOR             reduce using rule 72 (arith -> arith MINUS term .)
    LT              reduce using rule 72 (arith -> arith MINUS term .)
    GT              reduce using rule 72 (arith -> arith MINUS term .)
    LE              reduce using rule 72 (arith -> arith MINUS term .)
    GE              reduce using rule 72 (arith -> arith MINUS term .)
    NE              reduce using rule 72 (arith -> arith MINUS term .)
    DEQUAL          reduce using rule 72 (arith -> arith MINUS term .)
    AND             reduce using rule 72 (arith -> arith MINUS term .)
    OR              reduce using rule 72 (arith -> arith MINUS term .)
    SEMICOLON       reduce using rule 72 (arith -> arith MINUS term .)
    THEN            reduce using rule 72 (arith -> arith MINUS term .)
    RPAR            reduce using rule 72 (arith -> arith MINUS term .)
    COMMA           reduce using rule 72 (arith -> arith MINUS term .)
    RSQB            reduce using rule 72 (arith -> arith MINUS term .)
    MUL             shift and go to state 83
    DIV             shift and go to state 84
    MOD             shift and go to state 86
    POW             shift and go to state 82
    DIV2            shift and go to state 85


state 115

    (33) assign -> ID . TYPEIS type EQUAL expr
    (41) assign_left -> ID .
    (49) index_expr -> ID . LSQB expr RSQB
    (87) primary -> ID .
    (31) call_stmt -> ID . LPAR RPAR
    (32) call_stmt -> ID . LPAR args_list RPAR

    TYPEIS          shift and go to state 76
    EQUAL           reduce using rule 41 (assign_left -> ID .)
    PE              reduce using rule 41 (assign_left -> ID .)
    ME              reduce using rule 41 (assign_left -> ID .)
    SE              reduce using rule 41 (assign_left -> ID .)
    DSE             reduce using rule 41 (assign_left -> ID .)
    AE              reduce using rule 41 (assign_left -> ID .)
    DAE             reduce using rule 41 (assign_left -> ID .)
    LSQB            shift and go to state 77
    MUL             reduce using rule 87 (primary -> ID .)
    DIV             reduce using rule 87 (primary -> ID .)
    MOD             reduce using rule 87 (primary -> ID .)
    POW             reduce using rule 87 (primary -> ID .)
    DIV2            reduce using rule 87 (primary -> ID .)
    PLUS            reduce using rule 87 (primary -> ID .)
    MINUS           reduce using rule 87 (primary -> ID .)
    BAND            reduce using rule 87 (primary -> ID .)
    SHIFTLEFT       reduce using rule 87 (primary -> ID .)
    SHIFTRIGTH      reduce using rule 87 (primary -> ID .)
    BXOR            reduce using rule 87 (primary -> ID .)
    BOR             reduce using rule 87 (primary -> ID .)
    LT              reduce using rule 87 (primary -> ID .)
    GT              reduce using rule 87 (primary -> ID .)
    LE              reduce using rule 87 (primary -> ID .)
    GE              reduce using rule 87 (primary -> ID .)
    NE              reduce using rule 87 (primary -> ID .)
    DEQUAL          reduce using rule 87 (primary -> ID .)
    AND             reduce using rule 87 (primary -> ID .)
    OR              reduce using rule 87 (primary -> ID .)
    SEMICOLON       reduce using rule 87 (primary -> ID .)
    LPAR            shift and go to state 75


state 116

    (25) for_stmt -> FOR LPAR expr . SEMICOLON expr SEMICOLON expr RPAR THEN code_block

    SEMICOLON       shift and go to state 152


state 117

    (24) for_stmt -> FOR LPAR assign . SEMICOLON expr SEMICOLON expr RPAR code_block

    SEMICOLON       shift and go to state 153


state 118

    (95) primary_list -> primary_list COMMA . primary
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    ID              shift and go to state 74
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    list_def                       shift and go to state 13
    primary                        shift and go to state 154

state 119

    (93) list_def -> LSQB primary_list RSQB .

    MUL             reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    DIV             reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    MOD             reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    POW             reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    DIV2            reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    PLUS            reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    MINUS           reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    BAND            reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    SHIFTLEFT       reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    SHIFTRIGTH      reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    BXOR            reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    BOR             reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    LT              reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    GT              reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    LE              reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    GE              reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    NE              reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    DEQUAL          reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    AND             reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    OR              reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    SEMICOLON       reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    RPAR            reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    THEN            reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    COMMA           reduce using rule 93 (list_def -> LSQB primary_list RSQB .)
    RSQB            reduce using rule 93 (list_def -> LSQB primary_list RSQB .)


state 120

    (31) call_stmt -> ID LPAR RPAR .

    MUL             reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    DIV             reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    MOD             reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    POW             reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    DIV2            reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    PLUS            reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    MINUS           reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    BAND            reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    SHIFTLEFT       reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    SHIFTRIGTH      reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    BXOR            reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    BOR             reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    LT              reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    GT              reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    LE              reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    GE              reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    NE              reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    DEQUAL          reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    AND             reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    OR              reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    SEMICOLON       reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    RPAR            reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    THEN            reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    COMMA           reduce using rule 31 (call_stmt -> ID LPAR RPAR .)
    RSQB            reduce using rule 31 (call_stmt -> ID LPAR RPAR .)


state 121

    (32) call_stmt -> ID LPAR args_list . RPAR
    (44) args_list -> args_list . COMMA expr

    RPAR            shift and go to state 155
    COMMA           shift and go to state 156


state 122

    (43) args_list -> expr .

    RPAR            reduce using rule 43 (args_list -> expr .)
    COMMA           reduce using rule 43 (args_list -> expr .)


state 123

    (96) type -> TINT .

    RPAR            reduce using rule 96 (type -> TINT .)
    COMMA           reduce using rule 96 (type -> TINT .)
    THEN            reduce using rule 96 (type -> TINT .)
    LBRACE          reduce using rule 96 (type -> TINT .)
    EQUAL           reduce using rule 96 (type -> TINT .)


state 124

    (101) type -> CINT .

    RPAR            reduce using rule 101 (type -> CINT .)
    COMMA           reduce using rule 101 (type -> CINT .)
    THEN            reduce using rule 101 (type -> CINT .)
    LBRACE          reduce using rule 101 (type -> CINT .)
    EQUAL           reduce using rule 101 (type -> CINT .)


state 125

    (100) type -> TUPLE .

    RPAR            reduce using rule 100 (type -> TUPLE .)
    COMMA           reduce using rule 100 (type -> TUPLE .)
    THEN            reduce using rule 100 (type -> TUPLE .)
    LBRACE          reduce using rule 100 (type -> TUPLE .)
    EQUAL           reduce using rule 100 (type -> TUPLE .)


state 126

    (102) type -> CLONG .

    RPAR            reduce using rule 102 (type -> CLONG .)
    COMMA           reduce using rule 102 (type -> CLONG .)
    THEN            reduce using rule 102 (type -> CLONG .)
    LBRACE          reduce using rule 102 (type -> CLONG .)
    EQUAL           reduce using rule 102 (type -> CLONG .)


state 127

    (103) type -> CFLOAT .

    RPAR            reduce using rule 103 (type -> CFLOAT .)
    COMMA           reduce using rule 103 (type -> CFLOAT .)
    THEN            reduce using rule 103 (type -> CFLOAT .)
    LBRACE          reduce using rule 103 (type -> CFLOAT .)
    EQUAL           reduce using rule 103 (type -> CFLOAT .)


state 128

    (98) type -> TFLOAT .

    RPAR            reduce using rule 98 (type -> TFLOAT .)
    COMMA           reduce using rule 98 (type -> TFLOAT .)
    THEN            reduce using rule 98 (type -> TFLOAT .)
    LBRACE          reduce using rule 98 (type -> TFLOAT .)
    EQUAL           reduce using rule 98 (type -> TFLOAT .)


state 129

    (99) type -> ARRAY .

    RPAR            reduce using rule 99 (type -> ARRAY .)
    COMMA           reduce using rule 99 (type -> ARRAY .)
    THEN            reduce using rule 99 (type -> ARRAY .)
    LBRACE          reduce using rule 99 (type -> ARRAY .)
    EQUAL           reduce using rule 99 (type -> ARRAY .)


state 130

    (97) type -> TLONG .

    RPAR            reduce using rule 97 (type -> TLONG .)
    COMMA           reduce using rule 97 (type -> TLONG .)
    THEN            reduce using rule 97 (type -> TLONG .)
    LBRACE          reduce using rule 97 (type -> TLONG .)
    EQUAL           reduce using rule 97 (type -> TLONG .)


state 131

    (33) assign -> ID TYPEIS type . EQUAL expr

    EQUAL           shift and go to state 157


state 132

    (49) index_expr -> ID LSQB expr . RSQB

    RSQB            shift and go to state 158


state 133

    (70) par_expr -> LPAR arith . RPAR
    (71) arith -> arith . PLUS term
    (72) arith -> arith . MINUS term
    (69) shift -> arith .

  ! shift/reduce conflict for RPAR resolved as shift
    RPAR            shift and go to state 100
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    BAND            reduce using rule 69 (shift -> arith .)
    SHIFTLEFT       reduce using rule 69 (shift -> arith .)
    SHIFTRIGTH      reduce using rule 69 (shift -> arith .)
    BXOR            reduce using rule 69 (shift -> arith .)
    BOR             reduce using rule 69 (shift -> arith .)
    LT              reduce using rule 69 (shift -> arith .)
    GT              reduce using rule 69 (shift -> arith .)
    LE              reduce using rule 69 (shift -> arith .)
    GE              reduce using rule 69 (shift -> arith .)
    NE              reduce using rule 69 (shift -> arith .)
    DEQUAL          reduce using rule 69 (shift -> arith .)
    AND             reduce using rule 69 (shift -> arith .)
    OR              reduce using rule 69 (shift -> arith .)

  ! RPAR            [ reduce using rule 69 (shift -> arith .) ]


state 134

    (14) if_stmt -> IF LPAR expr . RPAR code_block elseifs_stmts else_stmt

    RPAR            shift and go to state 159


state 135

    (13) if_stmt -> IF expr THEN . code_block elseifs_stmts else_stmt
    (104) code_block -> . LBRACE input RBRACE

    LBRACE          shift and go to state 161

    code_block                     shift and go to state 160

state 136

    (77) term -> term POW factor .

    MUL             reduce using rule 77 (term -> term POW factor .)
    DIV             reduce using rule 77 (term -> term POW factor .)
    MOD             reduce using rule 77 (term -> term POW factor .)
    POW             reduce using rule 77 (term -> term POW factor .)
    DIV2            reduce using rule 77 (term -> term POW factor .)
    PLUS            reduce using rule 77 (term -> term POW factor .)
    MINUS           reduce using rule 77 (term -> term POW factor .)
    BAND            reduce using rule 77 (term -> term POW factor .)
    SHIFTLEFT       reduce using rule 77 (term -> term POW factor .)
    SHIFTRIGTH      reduce using rule 77 (term -> term POW factor .)
    BXOR            reduce using rule 77 (term -> term POW factor .)
    BOR             reduce using rule 77 (term -> term POW factor .)
    LT              reduce using rule 77 (term -> term POW factor .)
    GT              reduce using rule 77 (term -> term POW factor .)
    LE              reduce using rule 77 (term -> term POW factor .)
    GE              reduce using rule 77 (term -> term POW factor .)
    NE              reduce using rule 77 (term -> term POW factor .)
    DEQUAL          reduce using rule 77 (term -> term POW factor .)
    AND             reduce using rule 77 (term -> term POW factor .)
    OR              reduce using rule 77 (term -> term POW factor .)
    RPAR            reduce using rule 77 (term -> term POW factor .)
    COMMA           reduce using rule 77 (term -> term POW factor .)
    SEMICOLON       reduce using rule 77 (term -> term POW factor .)
    THEN            reduce using rule 77 (term -> term POW factor .)
    RSQB            reduce using rule 77 (term -> term POW factor .)


state 137

    (74) term -> term MUL factor .

    MUL             reduce using rule 74 (term -> term MUL factor .)
    DIV             reduce using rule 74 (term -> term MUL factor .)
    MOD             reduce using rule 74 (term -> term MUL factor .)
    POW             reduce using rule 74 (term -> term MUL factor .)
    DIV2            reduce using rule 74 (term -> term MUL factor .)
    PLUS            reduce using rule 74 (term -> term MUL factor .)
    MINUS           reduce using rule 74 (term -> term MUL factor .)
    BAND            reduce using rule 74 (term -> term MUL factor .)
    SHIFTLEFT       reduce using rule 74 (term -> term MUL factor .)
    SHIFTRIGTH      reduce using rule 74 (term -> term MUL factor .)
    BXOR            reduce using rule 74 (term -> term MUL factor .)
    BOR             reduce using rule 74 (term -> term MUL factor .)
    LT              reduce using rule 74 (term -> term MUL factor .)
    GT              reduce using rule 74 (term -> term MUL factor .)
    LE              reduce using rule 74 (term -> term MUL factor .)
    GE              reduce using rule 74 (term -> term MUL factor .)
    NE              reduce using rule 74 (term -> term MUL factor .)
    DEQUAL          reduce using rule 74 (term -> term MUL factor .)
    AND             reduce using rule 74 (term -> term MUL factor .)
    OR              reduce using rule 74 (term -> term MUL factor .)
    RPAR            reduce using rule 74 (term -> term MUL factor .)
    COMMA           reduce using rule 74 (term -> term MUL factor .)
    SEMICOLON       reduce using rule 74 (term -> term MUL factor .)
    THEN            reduce using rule 74 (term -> term MUL factor .)
    RSQB            reduce using rule 74 (term -> term MUL factor .)


state 138

    (75) term -> term DIV factor .

    MUL             reduce using rule 75 (term -> term DIV factor .)
    DIV             reduce using rule 75 (term -> term DIV factor .)
    MOD             reduce using rule 75 (term -> term DIV factor .)
    POW             reduce using rule 75 (term -> term DIV factor .)
    DIV2            reduce using rule 75 (term -> term DIV factor .)
    PLUS            reduce using rule 75 (term -> term DIV factor .)
    MINUS           reduce using rule 75 (term -> term DIV factor .)
    BAND            reduce using rule 75 (term -> term DIV factor .)
    SHIFTLEFT       reduce using rule 75 (term -> term DIV factor .)
    SHIFTRIGTH      reduce using rule 75 (term -> term DIV factor .)
    BXOR            reduce using rule 75 (term -> term DIV factor .)
    BOR             reduce using rule 75 (term -> term DIV factor .)
    LT              reduce using rule 75 (term -> term DIV factor .)
    GT              reduce using rule 75 (term -> term DIV factor .)
    LE              reduce using rule 75 (term -> term DIV factor .)
    GE              reduce using rule 75 (term -> term DIV factor .)
    NE              reduce using rule 75 (term -> term DIV factor .)
    DEQUAL          reduce using rule 75 (term -> term DIV factor .)
    AND             reduce using rule 75 (term -> term DIV factor .)
    OR              reduce using rule 75 (term -> term DIV factor .)
    RPAR            reduce using rule 75 (term -> term DIV factor .)
    COMMA           reduce using rule 75 (term -> term DIV factor .)
    SEMICOLON       reduce using rule 75 (term -> term DIV factor .)
    THEN            reduce using rule 75 (term -> term DIV factor .)
    RSQB            reduce using rule 75 (term -> term DIV factor .)


state 139

    (78) term -> term DIV2 factor .

    MUL             reduce using rule 78 (term -> term DIV2 factor .)
    DIV             reduce using rule 78 (term -> term DIV2 factor .)
    MOD             reduce using rule 78 (term -> term DIV2 factor .)
    POW             reduce using rule 78 (term -> term DIV2 factor .)
    DIV2            reduce using rule 78 (term -> term DIV2 factor .)
    PLUS            reduce using rule 78 (term -> term DIV2 factor .)
    MINUS           reduce using rule 78 (term -> term DIV2 factor .)
    BAND            reduce using rule 78 (term -> term DIV2 factor .)
    SHIFTLEFT       reduce using rule 78 (term -> term DIV2 factor .)
    SHIFTRIGTH      reduce using rule 78 (term -> term DIV2 factor .)
    BXOR            reduce using rule 78 (term -> term DIV2 factor .)
    BOR             reduce using rule 78 (term -> term DIV2 factor .)
    LT              reduce using rule 78 (term -> term DIV2 factor .)
    GT              reduce using rule 78 (term -> term DIV2 factor .)
    LE              reduce using rule 78 (term -> term DIV2 factor .)
    GE              reduce using rule 78 (term -> term DIV2 factor .)
    NE              reduce using rule 78 (term -> term DIV2 factor .)
    DEQUAL          reduce using rule 78 (term -> term DIV2 factor .)
    AND             reduce using rule 78 (term -> term DIV2 factor .)
    OR              reduce using rule 78 (term -> term DIV2 factor .)
    RPAR            reduce using rule 78 (term -> term DIV2 factor .)
    COMMA           reduce using rule 78 (term -> term DIV2 factor .)
    SEMICOLON       reduce using rule 78 (term -> term DIV2 factor .)
    THEN            reduce using rule 78 (term -> term DIV2 factor .)
    RSQB            reduce using rule 78 (term -> term DIV2 factor .)


state 140

    (76) term -> term MOD factor .

    MUL             reduce using rule 76 (term -> term MOD factor .)
    DIV             reduce using rule 76 (term -> term MOD factor .)
    MOD             reduce using rule 76 (term -> term MOD factor .)
    POW             reduce using rule 76 (term -> term MOD factor .)
    DIV2            reduce using rule 76 (term -> term MOD factor .)
    PLUS            reduce using rule 76 (term -> term MOD factor .)
    MINUS           reduce using rule 76 (term -> term MOD factor .)
    BAND            reduce using rule 76 (term -> term MOD factor .)
    SHIFTLEFT       reduce using rule 76 (term -> term MOD factor .)
    SHIFTRIGTH      reduce using rule 76 (term -> term MOD factor .)
    BXOR            reduce using rule 76 (term -> term MOD factor .)
    BOR             reduce using rule 76 (term -> term MOD factor .)
    LT              reduce using rule 76 (term -> term MOD factor .)
    GT              reduce using rule 76 (term -> term MOD factor .)
    LE              reduce using rule 76 (term -> term MOD factor .)
    GE              reduce using rule 76 (term -> term MOD factor .)
    NE              reduce using rule 76 (term -> term MOD factor .)
    DEQUAL          reduce using rule 76 (term -> term MOD factor .)
    AND             reduce using rule 76 (term -> term MOD factor .)
    OR              reduce using rule 76 (term -> term MOD factor .)
    RPAR            reduce using rule 76 (term -> term MOD factor .)
    COMMA           reduce using rule 76 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 76 (term -> term MOD factor .)
    THEN            reduce using rule 76 (term -> term MOD factor .)
    RSQB            reduce using rule 76 (term -> term MOD factor .)


state 141

    (61) or -> or BOR xor .
    (63) xor -> xor . BXOR and

    BOR             reduce using rule 61 (or -> or BOR xor .)
    LT              reduce using rule 61 (or -> or BOR xor .)
    GT              reduce using rule 61 (or -> or BOR xor .)
    LE              reduce using rule 61 (or -> or BOR xor .)
    GE              reduce using rule 61 (or -> or BOR xor .)
    NE              reduce using rule 61 (or -> or BOR xor .)
    DEQUAL          reduce using rule 61 (or -> or BOR xor .)
    AND             reduce using rule 61 (or -> or BOR xor .)
    OR              reduce using rule 61 (or -> or BOR xor .)
    SEMICOLON       reduce using rule 61 (or -> or BOR xor .)
    RPAR            reduce using rule 61 (or -> or BOR xor .)
    COMMA           reduce using rule 61 (or -> or BOR xor .)
    THEN            reduce using rule 61 (or -> or BOR xor .)
    RSQB            reduce using rule 61 (or -> or BOR xor .)
    BXOR            shift and go to state 61


state 142

    (54) cmp -> cmp GT cmp_expr .

    LT              reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    GT              reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    LE              reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    GE              reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    NE              reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    DEQUAL          reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    AND             reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    OR              reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    SEMICOLON       reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    RPAR            reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    THEN            reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    COMMA           reduce using rule 54 (cmp -> cmp GT cmp_expr .)
    RSQB            reduce using rule 54 (cmp -> cmp GT cmp_expr .)


state 143

    (58) cmp -> cmp DEQUAL cmp_expr .

    LT              reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    GT              reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    LE              reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    GE              reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    NE              reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    DEQUAL          reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    AND             reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    OR              reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    SEMICOLON       reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    RPAR            reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    THEN            reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    COMMA           reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)
    RSQB            reduce using rule 58 (cmp -> cmp DEQUAL cmp_expr .)


state 144

    (56) cmp -> cmp GE cmp_expr .

    LT              reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    GT              reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    LE              reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    GE              reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    NE              reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    DEQUAL          reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    AND             reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    OR              reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    SEMICOLON       reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    RPAR            reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    THEN            reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    COMMA           reduce using rule 56 (cmp -> cmp GE cmp_expr .)
    RSQB            reduce using rule 56 (cmp -> cmp GE cmp_expr .)


state 145

    (57) cmp -> cmp NE cmp_expr .

    LT              reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    GT              reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    LE              reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    GE              reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    NE              reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    DEQUAL          reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    AND             reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    OR              reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    SEMICOLON       reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    RPAR            reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    THEN            reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    COMMA           reduce using rule 57 (cmp -> cmp NE cmp_expr .)
    RSQB            reduce using rule 57 (cmp -> cmp NE cmp_expr .)


state 146

    (53) cmp -> cmp LT cmp_expr .

    LT              reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    GT              reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    LE              reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    GE              reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    NE              reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    DEQUAL          reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    AND             reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    OR              reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    SEMICOLON       reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    RPAR            reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    THEN            reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    COMMA           reduce using rule 53 (cmp -> cmp LT cmp_expr .)
    RSQB            reduce using rule 53 (cmp -> cmp LT cmp_expr .)


state 147

    (55) cmp -> cmp LE cmp_expr .

    LT              reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    GT              reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    LE              reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    GE              reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    NE              reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    DEQUAL          reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    AND             reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    OR              reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    SEMICOLON       reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    RPAR            reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    THEN            reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    COMMA           reduce using rule 55 (cmp -> cmp LE cmp_expr .)
    RSQB            reduce using rule 55 (cmp -> cmp LE cmp_expr .)


state 148

    (22) while_stmt -> WHILE LPAR expr RPAR . code_block
    (23) while_stmt -> WHILE LPAR expr RPAR . THEN code_block
    (104) code_block -> . LBRACE input RBRACE

    THEN            shift and go to state 163
    LBRACE          shift and go to state 161

    code_block                     shift and go to state 162

state 149

    (26) def_stmt -> DEF ID LPAR var_prototypes_list . RPAR TYPEIS type THEN code_block
    (27) def_stmt -> DEF ID LPAR var_prototypes_list . RPAR TYPEIS type code_block
    (28) var_prototypes_list -> var_prototypes_list . COMMA var_prototype

    RPAR            shift and go to state 164
    COMMA           shift and go to state 165


state 150

    (29) var_prototypes_list -> var_prototype .

    RPAR            reduce using rule 29 (var_prototypes_list -> var_prototype .)
    COMMA           reduce using rule 29 (var_prototypes_list -> var_prototype .)


state 151

    (30) var_prototype -> ID . TYPEIS type

    TYPEIS          shift and go to state 166


state 152

    (25) for_stmt -> FOR LPAR expr SEMICOLON . expr SEMICOLON expr RPAR THEN code_block
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 167
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    arith                          shift and go to state 20
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 153

    (24) for_stmt -> FOR LPAR assign SEMICOLON . expr SEMICOLON expr RPAR code_block
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    par_expr                       shift and go to state 6
    primary                        shift and go to state 26
    cmp_expr                       shift and go to state 17
    xor                            shift and go to state 12
    list_def                       shift and go to state 13
    factor                         shift and go to state 5
    test                           shift and go to state 18
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    call_stmt                      shift and go to state 48
    return_expr                    shift and go to state 25
    atom                           shift and go to state 29
    term                           shift and go to state 34
    expr                           shift and go to state 168
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp                            shift and go to state 43

state 154

    (95) primary_list -> primary_list COMMA primary .

    RSQB            reduce using rule 95 (primary_list -> primary_list COMMA primary .)
    COMMA           reduce using rule 95 (primary_list -> primary_list COMMA primary .)


state 155

    (32) call_stmt -> ID LPAR args_list RPAR .

    MUL             reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    DIV             reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    MOD             reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    POW             reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    DIV2            reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    PLUS            reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    MINUS           reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    BAND            reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    SHIFTLEFT       reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    SHIFTRIGTH      reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    BXOR            reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    BOR             reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    LT              reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    GT              reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    LE              reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    GE              reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    NE              reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    DEQUAL          reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    AND             reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    OR              reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    SEMICOLON       reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    RPAR            reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    THEN            reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    COMMA           reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)
    RSQB            reduce using rule 32 (call_stmt -> ID LPAR args_list RPAR .)


state 156

    (44) args_list -> args_list COMMA . expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    par_expr                       shift and go to state 6
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    expr                           shift and go to state 169
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 157

    (33) assign -> ID TYPEIS type EQUAL . expr
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 170
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 158

    (49) index_expr -> ID LSQB expr RSQB .

    SEMICOLON       reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    RPAR            reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    THEN            reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    EQUAL           reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    PE              reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    ME              reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    SE              reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    DSE             reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    AE              reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    DAE             reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    COMMA           reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)
    RSQB            reduce using rule 49 (index_expr -> ID LSQB expr RSQB .)


state 159

    (14) if_stmt -> IF LPAR expr RPAR . code_block elseifs_stmts else_stmt
    (104) code_block -> . LBRACE input RBRACE

    LBRACE          shift and go to state 161

    code_block                     shift and go to state 171

state 160

    (13) if_stmt -> IF expr THEN code_block . elseifs_stmts else_stmt
    (15) elseifs_stmts -> . elseifs_stmts elseif_stmt
    (16) elseifs_stmts -> . elseif_stmt
    (17) elseifs_stmts -> .
    (18) elseif_stmt -> . ELSEIF expr THEN code_block
    (19) elseif_stmt -> . ELSEIF LPAR expr RPAR code_block

  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSE            reduce using rule 17 (elseifs_stmts -> .)
    ELSEIF          shift and go to state 172

  ! ELSEIF          [ reduce using rule 17 (elseifs_stmts -> .) ]

    elseif_stmt                    shift and go to state 173
    elseifs_stmts                  shift and go to state 174

state 161

    (104) code_block -> LBRACE . input RBRACE
    (2) input -> . op
    (3) input -> . input op
    (4) input -> .
    (5) op -> . expr SEMICOLON
    (6) op -> . stmt SEMICOLON
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (7) stmt -> . def_stmt
    (8) stmt -> . if_stmt
    (9) stmt -> . call_stmt
    (10) stmt -> . while_stmt
    (11) stmt -> . for_stmt
    (12) stmt -> . assign
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (26) def_stmt -> . DEF ID LPAR var_prototypes_list RPAR TYPEIS type THEN code_block
    (27) def_stmt -> . DEF ID LPAR var_prototypes_list RPAR TYPEIS type code_block
    (13) if_stmt -> . IF expr THEN code_block elseifs_stmts else_stmt
    (14) if_stmt -> . IF LPAR expr RPAR code_block elseifs_stmts else_stmt
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (22) while_stmt -> . WHILE LPAR expr RPAR code_block
    (23) while_stmt -> . WHILE LPAR expr RPAR THEN code_block
    (24) for_stmt -> . FOR LPAR assign SEMICOLON expr SEMICOLON expr RPAR code_block
    (25) for_stmt -> . FOR LPAR expr SEMICOLON expr SEMICOLON expr RPAR THEN code_block
    (33) assign -> . ID TYPEIS type EQUAL expr
    (34) assign -> . assign_left EQUAL expr
    (35) assign -> . assign_left PE expr
    (36) assign -> . assign_left ME expr
    (37) assign -> . assign_left SE expr
    (38) assign -> . assign_left DSE expr
    (39) assign -> . assign_left AE expr
    (40) assign -> . assign_left DAE expr
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (41) assign_left -> . ID
    (42) assign_left -> . index_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

  ! shift/reduce conflict for LPAR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for EMARK resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LSQB resolved as shift
    RBRACE          reduce using rule 4 (input -> .)
    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 31
    DEF             shift and go to state 11
    IF              shift and go to state 33
    WHILE           shift and go to state 8
    FOR             shift and go to state 23
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

  ! LPAR            [ reduce using rule 4 (input -> .) ]
  ! RETURN          [ reduce using rule 4 (input -> .) ]
  ! ID              [ reduce using rule 4 (input -> .) ]
  ! DEF             [ reduce using rule 4 (input -> .) ]
  ! IF              [ reduce using rule 4 (input -> .) ]
  ! WHILE           [ reduce using rule 4 (input -> .) ]
  ! FOR             [ reduce using rule 4 (input -> .) ]
  ! EMARK           [ reduce using rule 4 (input -> .) ]
  ! MINUS           [ reduce using rule 4 (input -> .) ]
  ! PLUS            [ reduce using rule 4 (input -> .) ]
  ! NOT             [ reduce using rule 4 (input -> .) ]
  ! NUMBER          [ reduce using rule 4 (input -> .) ]
  ! FLOAT           [ reduce using rule 4 (input -> .) ]
  ! STRING          [ reduce using rule 4 (input -> .) ]
  ! LSQB            [ reduce using rule 4 (input -> .) ]

    and                            shift and go to state 1
    par_expr                       shift and go to state 6
    def_stmt                       shift and go to state 7
    primary                        shift and go to state 26
    assign_left                    shift and go to state 9
    cmp_expr                       shift and go to state 17
    xor                            shift and go to state 12
    list_def                       shift and go to state 13
    factor                         shift and go to state 5
    test                           shift and go to state 18
    input                          shift and go to state 175
    arith                          shift and go to state 20
    index_expr                     shift and go to state 21
    call_stmt                      shift and go to state 24
    return_expr                    shift and go to state 25
    stmt                           shift and go to state 27
    for_stmt                       shift and go to state 28
    atom                           shift and go to state 29
    term                           shift and go to state 34
    if_stmt                        shift and go to state 35
    expr                           shift and go to state 36
    or                             shift and go to state 37
    while_stmt                     shift and go to state 39
    shift                          shift and go to state 40
    op                             shift and go to state 42
    assign                         shift and go to state 38
    cmp                            shift and go to state 43

state 162

    (22) while_stmt -> WHILE LPAR expr RPAR code_block .

    SEMICOLON       reduce using rule 22 (while_stmt -> WHILE LPAR expr RPAR code_block .)


state 163

    (23) while_stmt -> WHILE LPAR expr RPAR THEN . code_block
    (104) code_block -> . LBRACE input RBRACE

    LBRACE          shift and go to state 161

    code_block                     shift and go to state 176

state 164

    (26) def_stmt -> DEF ID LPAR var_prototypes_list RPAR . TYPEIS type THEN code_block
    (27) def_stmt -> DEF ID LPAR var_prototypes_list RPAR . TYPEIS type code_block

    TYPEIS          shift and go to state 177


state 165

    (28) var_prototypes_list -> var_prototypes_list COMMA . var_prototype
    (30) var_prototype -> . ID TYPEIS type

    ID              shift and go to state 151

    var_prototype                  shift and go to state 178

state 166

    (30) var_prototype -> ID TYPEIS . type
    (96) type -> . TINT
    (97) type -> . TLONG
    (98) type -> . TFLOAT
    (99) type -> . ARRAY
    (100) type -> . TUPLE
    (101) type -> . CINT
    (102) type -> . CLONG
    (103) type -> . CFLOAT

    TINT            shift and go to state 123
    TLONG           shift and go to state 130
    TFLOAT          shift and go to state 128
    ARRAY           shift and go to state 129
    TUPLE           shift and go to state 125
    CINT            shift and go to state 124
    CLONG           shift and go to state 126
    CFLOAT          shift and go to state 127

    type                           shift and go to state 179

state 167

    (25) for_stmt -> FOR LPAR expr SEMICOLON expr . SEMICOLON expr RPAR THEN code_block

    SEMICOLON       shift and go to state 180


state 168

    (24) for_stmt -> FOR LPAR assign SEMICOLON expr . SEMICOLON expr RPAR code_block

    SEMICOLON       shift and go to state 181


state 169

    (44) args_list -> args_list COMMA expr .

    RPAR            reduce using rule 44 (args_list -> args_list COMMA expr .)
    COMMA           reduce using rule 44 (args_list -> args_list COMMA expr .)


state 170

    (33) assign -> ID TYPEIS type EQUAL expr .

    SEMICOLON       reduce using rule 33 (assign -> ID TYPEIS type EQUAL expr .)


state 171

    (14) if_stmt -> IF LPAR expr RPAR code_block . elseifs_stmts else_stmt
    (15) elseifs_stmts -> . elseifs_stmts elseif_stmt
    (16) elseifs_stmts -> . elseif_stmt
    (17) elseifs_stmts -> .
    (18) elseif_stmt -> . ELSEIF expr THEN code_block
    (19) elseif_stmt -> . ELSEIF LPAR expr RPAR code_block

  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSE            reduce using rule 17 (elseifs_stmts -> .)
    ELSEIF          shift and go to state 172

  ! ELSEIF          [ reduce using rule 17 (elseifs_stmts -> .) ]

    elseif_stmt                    shift and go to state 173
    elseifs_stmts                  shift and go to state 182

state 172

    (18) elseif_stmt -> ELSEIF . expr THEN code_block
    (19) elseif_stmt -> ELSEIF . LPAR expr RPAR code_block
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 183
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 184
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    arith                          shift and go to state 20
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 173

    (16) elseifs_stmts -> elseif_stmt .

    ELSE            reduce using rule 16 (elseifs_stmts -> elseif_stmt .)
    ELSEIF          reduce using rule 16 (elseifs_stmts -> elseif_stmt .)


state 174

    (13) if_stmt -> IF expr THEN code_block elseifs_stmts . else_stmt
    (15) elseifs_stmts -> elseifs_stmts . elseif_stmt
    (20) else_stmt -> . ELSE THEN code_block
    (21) else_stmt -> . ELSE code_block
    (18) elseif_stmt -> . ELSEIF expr THEN code_block
    (19) elseif_stmt -> . ELSEIF LPAR expr RPAR code_block

    ELSE            shift and go to state 185
    ELSEIF          shift and go to state 172

    elseif_stmt                    shift and go to state 186
    else_stmt                      shift and go to state 187

state 175

    (104) code_block -> LBRACE input . RBRACE
    (3) input -> input . op
    (5) op -> . expr SEMICOLON
    (6) op -> . stmt SEMICOLON
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (7) stmt -> . def_stmt
    (8) stmt -> . if_stmt
    (9) stmt -> . call_stmt
    (10) stmt -> . while_stmt
    (11) stmt -> . for_stmt
    (12) stmt -> . assign
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (26) def_stmt -> . DEF ID LPAR var_prototypes_list RPAR TYPEIS type THEN code_block
    (27) def_stmt -> . DEF ID LPAR var_prototypes_list RPAR TYPEIS type code_block
    (13) if_stmt -> . IF expr THEN code_block elseifs_stmts else_stmt
    (14) if_stmt -> . IF LPAR expr RPAR code_block elseifs_stmts else_stmt
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (22) while_stmt -> . WHILE LPAR expr RPAR code_block
    (23) while_stmt -> . WHILE LPAR expr RPAR THEN code_block
    (24) for_stmt -> . FOR LPAR assign SEMICOLON expr SEMICOLON expr RPAR code_block
    (25) for_stmt -> . FOR LPAR expr SEMICOLON expr SEMICOLON expr RPAR THEN code_block
    (33) assign -> . ID TYPEIS type EQUAL expr
    (34) assign -> . assign_left EQUAL expr
    (35) assign -> . assign_left PE expr
    (36) assign -> . assign_left ME expr
    (37) assign -> . assign_left SE expr
    (38) assign -> . assign_left DSE expr
    (39) assign -> . assign_left AE expr
    (40) assign -> . assign_left DAE expr
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (41) assign_left -> . ID
    (42) assign_left -> . index_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    RBRACE          shift and go to state 188
    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 31
    DEF             shift and go to state 11
    IF              shift and go to state 33
    WHILE           shift and go to state 8
    FOR             shift and go to state 23
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    par_expr                       shift and go to state 6
    def_stmt                       shift and go to state 7
    primary                        shift and go to state 26
    assign_left                    shift and go to state 9
    cmp_expr                       shift and go to state 17
    xor                            shift and go to state 12
    list_def                       shift and go to state 13
    factor                         shift and go to state 5
    test                           shift and go to state 18
    arith                          shift and go to state 20
    index_expr                     shift and go to state 21
    call_stmt                      shift and go to state 24
    return_expr                    shift and go to state 25
    stmt                           shift and go to state 27
    for_stmt                       shift and go to state 28
    atom                           shift and go to state 29
    term                           shift and go to state 34
    if_stmt                        shift and go to state 35
    expr                           shift and go to state 36
    or                             shift and go to state 37
    while_stmt                     shift and go to state 39
    shift                          shift and go to state 40
    op                             shift and go to state 66
    assign                         shift and go to state 38
    cmp                            shift and go to state 43

state 176

    (23) while_stmt -> WHILE LPAR expr RPAR THEN code_block .

    SEMICOLON       reduce using rule 23 (while_stmt -> WHILE LPAR expr RPAR THEN code_block .)


state 177

    (26) def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS . type THEN code_block
    (27) def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS . type code_block
    (96) type -> . TINT
    (97) type -> . TLONG
    (98) type -> . TFLOAT
    (99) type -> . ARRAY
    (100) type -> . TUPLE
    (101) type -> . CINT
    (102) type -> . CLONG
    (103) type -> . CFLOAT

    TINT            shift and go to state 123
    TLONG           shift and go to state 130
    TFLOAT          shift and go to state 128
    ARRAY           shift and go to state 129
    TUPLE           shift and go to state 125
    CINT            shift and go to state 124
    CLONG           shift and go to state 126
    CFLOAT          shift and go to state 127

    type                           shift and go to state 189

state 178

    (28) var_prototypes_list -> var_prototypes_list COMMA var_prototype .

    RPAR            reduce using rule 28 (var_prototypes_list -> var_prototypes_list COMMA var_prototype .)
    COMMA           reduce using rule 28 (var_prototypes_list -> var_prototypes_list COMMA var_prototype .)


state 179

    (30) var_prototype -> ID TYPEIS type .

    RPAR            reduce using rule 30 (var_prototype -> ID TYPEIS type .)
    COMMA           reduce using rule 30 (var_prototype -> ID TYPEIS type .)


state 180

    (25) for_stmt -> FOR LPAR expr SEMICOLON expr SEMICOLON . expr RPAR THEN code_block
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    index_expr                     shift and go to state 79
    factor                         shift and go to state 5
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 190
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    arith                          shift and go to state 20
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    xor                            shift and go to state 12
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 181

    (24) for_stmt -> FOR LPAR assign SEMICOLON expr SEMICOLON . expr RPAR code_block
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (60) cmp_expr -> . or
    (61) or -> . or BOR xor
    (62) or -> . xor
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    par_expr                       shift and go to state 6
    primary                        shift and go to state 26
    cmp_expr                       shift and go to state 17
    xor                            shift and go to state 12
    list_def                       shift and go to state 13
    factor                         shift and go to state 5
    test                           shift and go to state 18
    arith                          shift and go to state 20
    index_expr                     shift and go to state 79
    call_stmt                      shift and go to state 48
    return_expr                    shift and go to state 25
    atom                           shift and go to state 29
    term                           shift and go to state 34
    expr                           shift and go to state 191
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp                            shift and go to state 43

state 182

    (14) if_stmt -> IF LPAR expr RPAR code_block elseifs_stmts . else_stmt
    (15) elseifs_stmts -> elseifs_stmts . elseif_stmt
    (20) else_stmt -> . ELSE THEN code_block
    (21) else_stmt -> . ELSE code_block
    (18) elseif_stmt -> . ELSEIF expr THEN code_block
    (19) elseif_stmt -> . ELSEIF LPAR expr RPAR code_block

    ELSE            shift and go to state 185
    ELSEIF          shift and go to state 172

    elseif_stmt                    shift and go to state 186
    else_stmt                      shift and go to state 192

state 183

    (19) elseif_stmt -> ELSEIF LPAR . expr RPAR code_block
    (70) par_expr -> LPAR . arith RPAR
    (45) expr -> . par_expr
    (46) expr -> . test
    (47) expr -> . return_expr
    (48) expr -> . index_expr
    (71) arith -> . arith PLUS term
    (72) arith -> . arith MINUS term
    (73) arith -> . term
    (70) par_expr -> . LPAR arith RPAR
    (50) test -> . test AND cmp
    (51) test -> . test OR cmp
    (52) test -> . cmp
    (105) return_expr -> . RETURN test
    (49) index_expr -> . ID LSQB expr RSQB
    (74) term -> . term MUL factor
    (75) term -> . term DIV factor
    (76) term -> . term MOD factor
    (77) term -> . term POW factor
    (78) term -> . term DIV2 factor
    (79) term -> . factor
    (53) cmp -> . cmp LT cmp_expr
    (54) cmp -> . cmp GT cmp_expr
    (55) cmp -> . cmp LE cmp_expr
    (56) cmp -> . cmp GE cmp_expr
    (57) cmp -> . cmp NE cmp_expr
    (58) cmp -> . cmp DEQUAL cmp_expr
    (59) cmp -> . cmp_expr
    (80) factor -> . atom
    (81) factor -> . EMARK atom
    (82) factor -> . MINUS atom
    (83) factor -> . PLUS atom
    (84) factor -> . NOT atom
    (60) cmp_expr -> . or
    (85) atom -> . primary
    (86) atom -> . call_stmt
    (61) or -> . or BOR xor
    (62) or -> . xor
    (87) primary -> . ID
    (88) primary -> . NUMBER
    (89) primary -> . FLOAT
    (90) primary -> . STRING
    (91) primary -> . list_def
    (31) call_stmt -> . ID LPAR RPAR
    (32) call_stmt -> . ID LPAR args_list RPAR
    (63) xor -> . xor BXOR and
    (64) xor -> . and
    (92) list_def -> . LSQB RSQB
    (93) list_def -> . LSQB primary_list RSQB
    (65) and -> . and BAND shift
    (66) and -> . shift
    (67) shift -> . and SHIFTLEFT shift
    (68) shift -> . and SHIFTRIGTH shift
    (69) shift -> . arith

    LPAR            shift and go to state 2
    RETURN          shift and go to state 4
    ID              shift and go to state 80
    EMARK           shift and go to state 10
    MINUS           shift and go to state 14
    PLUS            shift and go to state 16
    NOT             shift and go to state 41
    NUMBER          shift and go to state 32
    FLOAT           shift and go to state 3
    STRING          shift and go to state 22
    LSQB            shift and go to state 30

    and                            shift and go to state 1
    term                           shift and go to state 34
    arith                          shift and go to state 133
    index_expr                     shift and go to state 79
    call_stmt                      shift and go to state 48
    expr                           shift and go to state 193
    return_expr                    shift and go to state 25
    list_def                       shift and go to state 13
    primary                        shift and go to state 26
    atom                           shift and go to state 29
    xor                            shift and go to state 12
    par_expr                       shift and go to state 6
    test                           shift and go to state 18
    factor                         shift and go to state 5
    shift                          shift and go to state 40
    or                             shift and go to state 37
    cmp_expr                       shift and go to state 17
    cmp                            shift and go to state 43

state 184

    (18) elseif_stmt -> ELSEIF expr . THEN code_block

    THEN            shift and go to state 194


state 185

    (20) else_stmt -> ELSE . THEN code_block
    (21) else_stmt -> ELSE . code_block
    (104) code_block -> . LBRACE input RBRACE

    THEN            shift and go to state 195
    LBRACE          shift and go to state 161

    code_block                     shift and go to state 196

state 186

    (15) elseifs_stmts -> elseifs_stmts elseif_stmt .

    ELSE            reduce using rule 15 (elseifs_stmts -> elseifs_stmts elseif_stmt .)
    ELSEIF          reduce using rule 15 (elseifs_stmts -> elseifs_stmts elseif_stmt .)


state 187

    (13) if_stmt -> IF expr THEN code_block elseifs_stmts else_stmt .

    SEMICOLON       reduce using rule 13 (if_stmt -> IF expr THEN code_block elseifs_stmts else_stmt .)


state 188

    (104) code_block -> LBRACE input RBRACE .

    SEMICOLON       reduce using rule 104 (code_block -> LBRACE input RBRACE .)
    ELSEIF          reduce using rule 104 (code_block -> LBRACE input RBRACE .)
    ELSE            reduce using rule 104 (code_block -> LBRACE input RBRACE .)


state 189

    (26) def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS type . THEN code_block
    (27) def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS type . code_block
    (104) code_block -> . LBRACE input RBRACE

    THEN            shift and go to state 198
    LBRACE          shift and go to state 161

    code_block                     shift and go to state 197

state 190

    (25) for_stmt -> FOR LPAR expr SEMICOLON expr SEMICOLON expr . RPAR THEN code_block

    RPAR            shift and go to state 199


state 191

    (24) for_stmt -> FOR LPAR assign SEMICOLON expr SEMICOLON expr . RPAR code_block

    RPAR            shift and go to state 200


state 192

    (14) if_stmt -> IF LPAR expr RPAR code_block elseifs_stmts else_stmt .

    SEMICOLON       reduce using rule 14 (if_stmt -> IF LPAR expr RPAR code_block elseifs_stmts else_stmt .)


state 193

    (19) elseif_stmt -> ELSEIF LPAR expr . RPAR code_block

    RPAR            shift and go to state 201


state 194

    (18) elseif_stmt -> ELSEIF expr THEN . code_block
    (104) code_block -> . LBRACE input RBRACE

    LBRACE          shift and go to state 161

    code_block                     shift and go to state 202

state 195

    (20) else_stmt -> ELSE THEN . code_block
    (104) code_block -> . LBRACE input RBRACE

    LBRACE          shift and go to state 161

    code_block                     shift and go to state 203

state 196

    (21) else_stmt -> ELSE code_block .

    SEMICOLON       reduce using rule 21 (else_stmt -> ELSE code_block .)


state 197

    (27) def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS type code_block .

    SEMICOLON       reduce using rule 27 (def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS type code_block .)


state 198

    (26) def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS type THEN . code_block
    (104) code_block -> . LBRACE input RBRACE

    LBRACE          shift and go to state 161

    code_block                     shift and go to state 204

state 199

    (25) for_stmt -> FOR LPAR expr SEMICOLON expr SEMICOLON expr RPAR . THEN code_block

    THEN            shift and go to state 205


state 200

    (24) for_stmt -> FOR LPAR assign SEMICOLON expr SEMICOLON expr RPAR . code_block
    (104) code_block -> . LBRACE input RBRACE

    LBRACE          shift and go to state 161

    code_block                     shift and go to state 206

state 201

    (19) elseif_stmt -> ELSEIF LPAR expr RPAR . code_block
    (104) code_block -> . LBRACE input RBRACE

    LBRACE          shift and go to state 161

    code_block                     shift and go to state 207

state 202

    (18) elseif_stmt -> ELSEIF expr THEN code_block .

    ELSE            reduce using rule 18 (elseif_stmt -> ELSEIF expr THEN code_block .)
    ELSEIF          reduce using rule 18 (elseif_stmt -> ELSEIF expr THEN code_block .)


state 203

    (20) else_stmt -> ELSE THEN code_block .

    SEMICOLON       reduce using rule 20 (else_stmt -> ELSE THEN code_block .)


state 204

    (26) def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS type THEN code_block .

    SEMICOLON       reduce using rule 26 (def_stmt -> DEF ID LPAR var_prototypes_list RPAR TYPEIS type THEN code_block .)


state 205

    (25) for_stmt -> FOR LPAR expr SEMICOLON expr SEMICOLON expr RPAR THEN . code_block
    (104) code_block -> . LBRACE input RBRACE

    LBRACE          shift and go to state 161

    code_block                     shift and go to state 208

state 206

    (24) for_stmt -> FOR LPAR assign SEMICOLON expr SEMICOLON expr RPAR code_block .

    SEMICOLON       reduce using rule 24 (for_stmt -> FOR LPAR assign SEMICOLON expr SEMICOLON expr RPAR code_block .)


state 207

    (19) elseif_stmt -> ELSEIF LPAR expr RPAR code_block .

    ELSE            reduce using rule 19 (elseif_stmt -> ELSEIF LPAR expr RPAR code_block .)
    ELSEIF          reduce using rule 19 (elseif_stmt -> ELSEIF LPAR expr RPAR code_block .)


state 208

    (25) for_stmt -> FOR LPAR expr SEMICOLON expr SEMICOLON expr RPAR THEN code_block .

    SEMICOLON       reduce using rule 25 (for_stmt -> FOR LPAR expr SEMICOLON expr SEMICOLON expr RPAR THEN code_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAR in state 0 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for DEF in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for EMARK in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for LSQB in state 0 resolved as shift
WARNING: shift/reduce conflict for RPAR in state 133 resolved as shift
WARNING: shift/reduce conflict for ELSEIF in state 160 resolved as shift
WARNING: shift/reduce conflict for LPAR in state 161 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 161 resolved as shift
WARNING: shift/reduce conflict for ID in state 161 resolved as shift
WARNING: shift/reduce conflict for DEF in state 161 resolved as shift
WARNING: shift/reduce conflict for IF in state 161 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 161 resolved as shift
WARNING: shift/reduce conflict for FOR in state 161 resolved as shift
WARNING: shift/reduce conflict for EMARK in state 161 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 161 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 161 resolved as shift
WARNING: shift/reduce conflict for NOT in state 161 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 161 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 161 resolved as shift
WARNING: shift/reduce conflict for STRING in state 161 resolved as shift
WARNING: shift/reduce conflict for LSQB in state 161 resolved as shift
WARNING: shift/reduce conflict for ELSEIF in state 171 resolved as shift
WARNING: reduce/reduce conflict in state 24 resolved using rule (stmt -> call_stmt)
WARNING: rejected rule (atom -> call_stmt) in state 24
WARNING: reduce/reduce conflict in state 97 resolved using rule (and -> and BAND shift)
WARNING: rejected rule (and -> shift) in state 97
WARNING: reduce/reduce conflict in state 98 resolved using rule (and -> shift)
WARNING: rejected rule (shift -> and SHIFTRIGTH shift) in state 98
WARNING: reduce/reduce conflict in state 99 resolved using rule (and -> shift)
WARNING: rejected rule (shift -> and SHIFTLEFT shift) in state 99
